/*
 * Copyright (C) 2019-2023 Advanced Micro Devices, Inc. All rights reserved.
 */

#pragma once

#include "os_base_type.h"
#include "paramtypes.h"

#define FW_VERSION_MAJOR_SHIFT          (24)
#define FW_VERSION_MINOR_SHIFT          (16)
#define FW_VERSION_REVISION_SHIFT       (8)
#define FW_VERSION_SUB_REVISION_SHIFT   (0)

#define FW_VERSION_MAJOR_MASK           (0xff << FW_VERSION_MAJOR_SHIFT)
#define FW_VERSION_MINOR_MASK           (0xff << FW_VERSION_MINOR_SHIFT)
#define FW_VERSION_REVISION_MASK        (0xff << FW_VERSION_REVISION_SHIFT)
#define FW_VERSION_SUB_REVISION_MASK    (0xff << FW_VERSION_SUB_REVISION_SHIFT)

#define FW_VERSION_MAJOR          (0x3)
#define FW_VERSION_MINOR          (0xb)
#define FW_VERSION_REVISION       (0x6)
#define FW_VERSION_SUB_REVISION   (0x3)
#define FW_VERSION_STRING "ISP Firmware Version: 3.b.6.3"
#define FW_VERSION (((FW_VERSION_MAJOR & 0xff) << FW_VERSION_MAJOR_SHIFT) |\
	((FW_VERSION_MINOR & 0xff) << FW_VERSION_MINOR_SHIFT) |\
	((FW_VERSION_REVISION & 0xff) << FW_VERSION_REVISION_SHIFT) |\
	((FW_VERSION_SUB_REVISION & 0xff) << FW_VERSION_SUB_REVISION_SHIFT))


//-----------                                        ------------
//|         |       ---------------------------      |          |
//|         |  ---->|  NonBlock Command       |----> |          |
//|         |       ---------------------------      |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |       ---------------------------      |          |
//|         |  ---->|  Stream1 Block Command  |----> |          |
//|         |       ---------------------------      |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |       ---------------------------      |          |
//|         |  ---->|  Stream2 Block Command  |----> |          |
//|         |       ---------------------------      |          |
//|         |                   .                    |          |
//|         |                   .                    |          |
//|         |                   .                    |          |
//|         |       ---------------------------      |          |
//|         |  ---->|  StreamX Block Command  |----> |          |
//|         |       ---------------------------      |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |                                        |          |
//|  HOST   |                                        | Firmware |
//|         |                                        |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |       --------------------------       |          |
//|         |  <----|  Global Response       |<----  |          |
//|         |       --------------------------       |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |       --------------------------       |          |
//|         |  <----|  Stream1 response      |<----  |          |
//|         |       --------------------------       |          |
//|         |                                        |          |
//|         |                                        |          |
//|         |       --------------------------       |          |
//|         |  <----|  Stream2 Response      |<----  |          |
//|         |       --------------------------       |          |
//|         |                   .                    |          |
//|         |                   .                    |          |
//|         |                   .                    |          |
//|         |       --------------------------       |          |
//|         |  <----|  StreamX Response      |<----  |          |
//|         |       --------------------------       |          |
//|         |                                        |          |
//-----------                                        ------------

//==================================
//Ring Buffer Registers Allocation:
//==================================
//TODO
// NonBlock Command:     mmISP_RB_BASE_LO1 mmISP_RB_BASE_HI1,
//mmISP_RB_SIZE1,
// mmISP_RB_RPTR1, mmISP_RB_WPTR1
// Stream1 Block Command: mmISP_RB_BASE_LO2 mmISP_RB_BASE_HI2,
// mmISP_RB_SIZE2,
// mmISP_RB_RPTR2, mmISP_RB_WPTR2
// Stream2 Block Command: mmISP_RB_BASE_LO3 mmISP_RB_BASE_HI3,
// mmISP_RB_SIZE3,
// mmISP_RB_RPTR3, mmISP_RB_WPTR3
// Stream3 Block Command: mmISP_RB_BASE_LO4 mmISP_RB_BASE_HI4,
// mmISP_RB_SIZE4,
// mmISP_RB_RPTR4, mmISP_RB_WPTR4
// Global Response:       mmISP_RB_BASE_LO9 mmISP_RB_BASE_HI9,
// mmISP_RB_SIZE9,
// mmISP_RB_RPTR9, mmISP_RB_WPTR9
// Stream1 Response:      mmISP_RB_BASE_LO10 mmISP_RB_BASE_HI10,
// mmISP_RB_SIZE10, mmISP_RB_RPTR10, mmISP_RB_WPTR10
// Stream2 Response:      mmISP_RB_BASE_LO11 mmISP_RB_BASE_HI11,
// mmISP_RB_SIZE11, mmISP_RB_RPTR11, mmISP_RB_WPTR11
// Stream3 Response:      mmISP_RB_BASE_LO12 mmISP_RB_BASE_HI12,
// mmISP_RB_SIZE12, mmISP_RB_RPTR12, mmISP_RB_WPTR12


/* ----------------------------------------------------------------- */
/*					Command ID List		     */
/* ----------------------------------------------------------------- */

/* cmdId is in the format of following type:
 * |<-Bit31 ~ Bit24->|<-Bit23 ~ Bit16->|<-Bit15 ~ Bit0->|
 * |      type       |      group      |       id       |
 */

#define CMD_TYPE_SHIFT                  (24)
#define CMD_TYPE_MASK                   (0xff << CMD_TYPE_SHIFT)
#define CMD_GROUP_SHIFT                 (16)
#define CMD_GROUP_MASK                  (0xff << CMD_GROUP_SHIFT)
#define CMD_ID_MASK                     (0xffff)


#define CMD_TYPE_GLOBAL_CTRL            (0x1 << CMD_TYPE_SHIFT)
#define CMD_TYPE_STREAM_CTRL            (0x2 << CMD_TYPE_SHIFT)


#define GET_CMD_TYPE_VALUE(cmdId) ((cmdId & CMD_TYPE_MASK) >> CMD_TYPE_SHIFT)
#define GET_CMD_GROUP_VALUE(cmdId) ((cmdId & CMD_GROUP_MASK) >> CMD_GROUP_SHIFT)
#define GET_CMD_ID_VALUE(cmdId)         (cmdId & CMD_ID_MASK)


/* Groups for CMD_TYPE_GLOBAL_CTRL */
#define CMD_GROUP_GLOBAL_GENERAL            (0x1  << CMD_GROUP_SHIFT)
#define CMD_GROUP_GLOBAL_DEBUG              (0x2  << CMD_GROUP_SHIFT)
#define CMD_GROUP_GLOBAL_SENSOR             (0x3  << CMD_GROUP_SHIFT)
#define CMD_GROUP_GLOBAL_DEVICE             (0x4  << CMD_GROUP_SHIFT)
#define CMD_GROUP_GLOBAL_I2C                (0x5  << CMD_GROUP_SHIFT)
#define CMD_GROUP_GLOBAL_CLOCK_POWER_CTRL   (0x6  << CMD_GROUP_SHIFT)

/* Groups for CMD_TYPE_STREAM_CTRL */
#define CMD_GROUP_STREAM_GENERAL            (0x1  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_OUT_CH             (0x2  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_CTRL               (0x3  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_INFO               (0x4  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_FRAME              (0x5 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_BUFFER             (0x6 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_CAPTURE            (0x7  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_BLS                (0x8  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_DIR                (0x9 << CMD_GROUP_SHIFT)
//YUV_NR  //TODO
#define CMD_GROUP_STREAM_CPROC              (0xa  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_DITH_FCLIP_HFLIP   (0xb << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_SHARPEN            (0xc << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_DEGAMMA            (0xd  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_IE                 (0xe << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_YUV_NR             (0xf << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_AE                 (0x10  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_AWB                (0x11  << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_AF                 (0x12  << CMD_GROUP_SHIFT)
//CorePipe
#define CMD_GROUP_STREAM_DPC                (0x13 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_SNR                (0x14 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_TNR                (0x15 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_CAC                (0x16 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_RLSC               (0x17 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_MLSC               (0x18 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_IRIDIX             (0x19 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_DEMOSAIC           (0x1a << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_PF                 (0x1b << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_CNR                (0x1c << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_GAMMA              (0x1d << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_CS                 (0x1e << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_FR_SHARPEN         (0x1f << CMD_GROUP_SHIFT)
//
#define CMD_GROUP_STREAM_DGHDR              (0x20 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_PDZZ               (0x21 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_BRSZ               (0x22 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_RSZ                (0x23 << CMD_GROUP_SHIFT)
#define CMD_GROUP_STREAM_M2M                (0x24 << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_SECURE             (0x25 << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_GE                 (0x26 << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_CRISP              (0x27 << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_LSC                (0x28  << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_NONEQUILGAMMA      (0x29  << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_AUTOCONTRAST       (0x2A  << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_3DLUT              (0x2B  << CMD_GROUP_SHIFT)

#define CMD_GROUP_STREAM_TDB                (0x2C  << CMD_GROUP_SHIFT)

#define CMD_ID_INVALID                                  (0xffffffff)
/* ++++++++++++++++++++++++++*/
/*  Global CTRL Command   */
/* ++++++++++++++++++++++++++*/

/* General Command */
#define CMD_ID_GET_FW_VERSION \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_GENERAL | 0x1)
#define CMD_ID_SET_CLK_INFO \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_GENERAL | 0x2)
#define CMD_ID_PREPARE_CHANGE_ICLK \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_GENERAL | 0x3)
#define CMD_ID_SET_ZOOM_TMP_BUF \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_GENERAL | 0x4)
#define CMD_ID_CONFIG_MMHUB_PREFETCH \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_GENERAL | 0x5)


/* Debug Command */
#define CMD_ID_READ_REG \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x1)
#define CMD_ID_WRITE_REG \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x2)
#define CMD_ID_LOG_SET_LEVEL \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x3)
#define CMD_ID_LOG_ENABLE_MOD \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x4)
#define CMD_ID_LOG_DISABLE_MOD \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x5)
#define CMD_ID_PROFILER_GET_RESULT \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x6)
#define CMD_ID_SET_LOG_MOD_EXT \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x7)
#define CMD_ID_GET_ALL_TASK_STATS \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEBUG | 0x8)

/* Sensor Related Command */
#define CMD_ID_SET_SENSOR_PROP \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x1)
#define CMD_ID_SET_SENSOR_HDR_PROP \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x2)
#define CMD_ID_SET_SENSOR_CALIBDB \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x3)
#define CMD_ID_SET_SENSOR_EMB_PROP \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x4)
#define CMD_ID_CONFIG_CVIP_SENSOR \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x5)
#define CMD_ID_START_CVIP_SENSOR \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x6)
#define CMD_ID_STOP_CVIP_SENSOR \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x7)
#define CMD_ID_STANDBY_CVIP_SENSOR \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x8)
#define CMD_ID_SET_CVIP_BUF_LAYOUT \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0x9)
#define CMD_ID_SET_SENSOR_PD_PROP \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0xa)
#define CMD_ID_SET_SENSOR_SLICE_NUM \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0xb)
#define CMD_ID_UPDATE_SENSOR_CALIBDB \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_SENSOR | 0xc)

/* Device CTRL Command */
#define CMD_ID_SET_DEVICE_CTRL_MODE \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x1)
#define CMD_ID_SET_DEVICE_SCRIPT \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x2)
#define CMD_ID_ACK_SENSOR_GROUP_HOLD \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x3)
#define CMD_ID_ACK_SENSOR_GROUP_RELEASE \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x4)
#define CMD_ID_ACK_SENSOR_SET_AGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x5)
#define CMD_ID_ACK_SENSOR_SET_DGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x6)
#define CMD_ID_ACK_SENSOR_SET_ITIME \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x7)
#define CMD_ID_ACK_SENSOR_SET_HDR_HIGH_ITIME \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x8)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_ITIME \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x9)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_ITIME_RATIO \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xa)
#define CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_ITIME \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xb)
#define CMD_ID_ACK_SENSOR_SET_HDR_HIGH_AGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xc)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_AGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xd)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_AGAIN_RATIO \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xe)
#define CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_AGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0xf)
#define CMD_ID_ACK_SENSOR_SET_HDR_HIGH_DGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x10)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_DGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x11)
#define CMD_ID_ACK_SENSOR_SET_HDR_LOW_DGAIN_RATIO \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x12)
#define CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_DGAIN \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x13)
#define CMD_ID_ACK_LENS_SET_POS \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x14)
#define CMD_ID_ACK_FLASH_SET_POWER \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x15)
#define CMD_ID_ACK_FLASH_SET_ON \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x16)
#define CMD_ID_ACK_FLASH_SET_OFF \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_DEVICE | 0x17)

/* I2c CTRL Command */
#define CMD_ID_SEND_I2C_MSG \
			(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_I2C | 0x1)

/* Clock and Power CTRL Command */
#define CMD_ID_ENABLE_CLOCK_GATING \
	(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_CLOCK_POWER_CTRL | 0x1)
#define CMD_ID_DISABLE_CLOCK_GATING \
	(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_CLOCK_POWER_CTRL | 0x2)
#define CMD_ID_ENABLE_POWER_GATING \
	(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_CLOCK_POWER_CTRL | 0x3)
#define CMD_ID_DISABLE_POWER_GATING \
	(CMD_TYPE_GLOBAL_CTRL | CMD_GROUP_GLOBAL_CLOCK_POWER_CTRL | 0x4)


/* ++++++++++++++++++++++++++*/
/*  Stream CTRL Command   */
/* ++++++++++++++++++++++++++*/

/* General  Command */
#define CMD_ID_SET_STREAM_PATH \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x1)
// Acq wind only for mipi path?
#define CMD_ID_SET_ACQ_WINDOW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x2)
#define CMD_ID_ENABLE_CALIB \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x3)
#define CMD_ID_DISABLE_CALIB \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x4)
#define CMD_ID_SET_ASPECT_RATIO_WINDOW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x5)
#define CMD_ID_SET_ZOOM_WINDOW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x6)

// Only for mipi case
#define CMD_ID_SET_IR_ILLU_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x7)
#define CMD_ID_SET_CSM_YUV_RANGE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x8)
#define CMD_ID_SET_RAW_PKT_FMT \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x9)

#define CMD_ID_SET_LOOPBACK_CFA_PATTERN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xa)
#define CMD_ID_SET_RESIZE_ZOOM_WINDOW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xb)
//Specify the DIR output frame type. Only need to config in the
//usecase of HW DIR for RGB-IR sensor input
#define CMD_ID_SET_DIR_OUTPUT_FRAME_TYPE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xc)
#define CMD_ID_SET_LOOPBACK_PDAF_TYPE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xd)
#define CMD_ID_GET_TOP_BYPASS_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xe)
#define CMD_ID_ENABLE_ENGINEERING_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0xf)
#define CMD_ID_DISABLE_ENGINEERING_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GENERAL | 0x10)

#define CMD_ID_SET_OUT_CH_PROP \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_OUT_CH | 0x1)
#define CMD_ID_SET_OUT_CH_FRAME_RATE_RATIO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_OUT_CH | 0x2)
#define CMD_ID_ENABLE_OUT_CH \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_OUT_CH | 0x3)
#define CMD_ID_DISABLE_OUT_CH \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_OUT_CH | 0x4)

// Capture zsl yuv
#define CMD_ID_CAPTURE_YUV \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAPTURE | 0x1)
#define CMD_ID_CAPTURE_RAW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAPTURE | 0x2)
#define CMD_ID_CAPTURE_FULL_YUV \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAPTURE | 0x3)

/* Stream  Command */
#define CMD_ID_START_STREAM \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CTRL | 0x1)
#define CMD_ID_STOP_STREAM \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CTRL | 0x2)
#define CMD_ID_RESET_STREAM \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CTRL | 0x3)

/*  Frame Rate Info Command */
#define CMD_ID_SET_FRAME_RATE_INFO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_INFO | 0x1)
#define CMD_ID_SET_FRAME_CTRL_RATIO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_INFO | 0x2)

/* AE  Command */
#define CMD_ID_AE_SET_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1)
#define CMD_ID_AE_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x2)
#define CMD_ID_AE_LOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x3)
#define CMD_ID_AE_UNLOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x4)
#define CMD_ID_AE_SET_REGION \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x5)
#define CMD_ID_AE_SET_FLICKER \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x6)
#define CMD_ID_AE_SET_ANALOG_GAIN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x7)
#define CMD_ID_AE_SET_DIGITAL_GAIN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x8)
#define CMD_ID_AE_SET_ISP_GAIN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x9)
#define CMD_ID_AE_SET_ITIME \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xa)
#define CMD_ID_AE_SET_ISO_PRIORITY \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xb)
#define CMD_ID_AE_SET_ITIME_PRIORITY \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xc)
#define CMD_ID_AE_SET_EV_COMPENSATION \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xd)
#define CMD_ID_AE_PRECAPTURE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xe)
#define CMD_ID_AE_SET_FPS_RANGE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0xf)
#define CMD_ID_AE_SET_ISO_RANGE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x10)
#define CMD_ID_AE_SET_ITIME_RANGE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x11)
#define CMD_ID_AE_ENABLE_HDR \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x12)
#define CMD_ID_AE_DISABLE_HDR \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x13)
#define CMD_ID_AE_SET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x14)
#define CMD_ID_AE_GET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x15)
#define CMD_ID_AE_SET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x16)
#define CMD_ID_AE_GET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x17)
#define CMD_ID_AE_SET_PLINE_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x18)
#define CMD_ID_AE_GET_PLINE_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x19)
#define CMD_ID_AE_SET_EV \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1a)
#define CMD_ID_AE_SET_SCENE_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1b)
#define CMD_ID_AE_SET_SCENARIO_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1c)
#define CMD_ID_AE_SET_FRAME_DURATION \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1d)
#define CMD_ID_AE_SET_TOUCH_TARGET \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1e)
#define CMD_ID_AE_SET_TOUCH_TARGET_WEIGHT \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x1f)
#define CMD_ID_AE_SET_APPLY_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AE | 0x20)

/* AWB  Command */
#define CMD_ID_AWB_SET_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x1)
#define CMD_ID_AWB_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x2)
#define CMD_ID_AWB_LOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x3)
#define CMD_ID_AWB_UNLOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x4)
#define CMD_ID_AWB_SET_WB_GAIN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x5)
#define CMD_ID_AWB_GET_WB_GAIN \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x6)
#define CMD_ID_AWB_SET_CC_MATRIX \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x7)
#define CMD_ID_AWB_GET_CC_MATRIX \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x8)
#define CMD_ID_AWB_SET_LIGHT_SOURCE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0x9)
#define CMD_ID_AWB_SET_COLOR_TEMPERATURE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0xa)
#define CMD_ID_AWB_SET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0xb)
#define CMD_ID_AWB_GET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0xc)
#define CMD_ID_AWB_SET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0xd)
#define CMD_ID_AWB_GET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AWB | 0xe)

/* AF  Command */
#define CMD_ID_AF_SET_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x1)
#define CMD_ID_AF_SET_LENS_RANGE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x2)
#define CMD_ID_AF_SET_LENS_POS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x3)
#define CMD_ID_AF_SET_REGION \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x4)
#define CMD_ID_AF_TRIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x5)
#define CMD_ID_AF_CANCEL \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x6)
#define CMD_ID_AF_LOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x7)
#define CMD_ID_AF_UNLOCK \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x8)
#define CMD_ID_AF_SET_FOCUS_ASSIST_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x9)
#define CMD_ID_AF_SET_FOCUS_ASSIST_POWER_LEVEL \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xa)
#define CMD_ID_AF_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xb)
#define CMD_ID_AF_SET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xc)
#define CMD_ID_AF_GET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xd)
#define CMD_ID_AF_SET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xe)
#define CMD_ID_AF_GET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0xf)
#define CMD_ID_AF_SET_SEARCH_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x10)
#define CMD_ID_AF_SET_CALIB_TYPE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AF | 0x11)


/* CPROC  Command */
#define CMD_ID_CPROC_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x1)
#define CMD_ID_CPROC_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x2)
#define CMD_ID_CPROC_SET_CONTRAST \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x3)
#define CMD_ID_CPROC_SET_BRIGHTNESS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x4)
#define CMD_ID_CPROC_SET_SATURATION \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x5)
#define CMD_ID_CPROC_SET_HUE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x6)
#define CMD_ID_CPROC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CPROC | 0x7)


//CorePipe
/* DPC Command */
#define CMD_ID_DPC_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DPC | 0x1)
#define CMD_ID_DPC_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DPC | 0x2)
#define CMD_ID_DPC_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DPC | 0x3)
#define CMD_ID_DPC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DPC | 0x4)


/* SNR Command */
#define CMD_ID_SNR_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SNR | 0x1)
#define CMD_ID_SNR_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SNR | 0x2)
#define CMD_ID_SNR_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SNR | 0x3)
#define CMD_ID_SNR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SNR | 0x4)


/* TNR Command */
#define CMD_ID_TNR_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TNR | 0x1)
#define CMD_ID_TNR_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TNR | 0x2)
#define CMD_ID_TNR_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TNR | 0x3)
#define CMD_ID_TNR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TNR | 0x4)


/* CAC  Command */
#define CMD_ID_CAC_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAC | 0x1)
#define CMD_ID_CAC_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAC | 0x2)
#define CMD_ID_CAC_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAC | 0x3)
#define CMD_ID_CAC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CAC | 0x4)


/* RLSC  Command */
#define CMD_ID_RLSC_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_RLSC | 0x1)
#define CMD_ID_RLSC_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_RLSC | 0x2)
#define CMD_ID_RLSC_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_RLSC | 0x3)
#define CMD_ID_RLSC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_RLSC | 0x4)


/* MLSC  Command */
#define CMD_ID_MLSC_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_MLSC | 0x1)
#define CMD_ID_MLSC_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_MLSC | 0x2)
#define CMD_ID_MLSC_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_MLSC | 0x3)
#define CMD_ID_MLSC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_MLSC | 0x4)


/* IRIDIX  Command */
#define CMD_ID_IRIDIX_SET_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x1)
#define CMD_ID_IRIDIX_SET_CTRL_INFO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x2)
#define CMD_ID_IRIDIX_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x3)
#define CMD_ID_IRIDIX_SET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x4)
#define CMD_ID_IRIDIX_GET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x5)
#define CMD_ID_IRIDIX_SET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x6)
#define CMD_ID_IRIDIX_GET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x7)
#define CMD_ID_IRIDIX_GET_CTRL_INFO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_IRIDIX | 0x8)


/* DEMOSAIC  Command */
#define CMD_ID_DEMOSAIC_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEMOSAIC | 0x1)
#define CMD_ID_DEMOSAIC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEMOSAIC | 0x2)


/* PF  Command */
#define CMD_ID_PF_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_PF | 0x1)
#define CMD_ID_PF_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_PF | 0x2)


/* CNR  Command */
#define CMD_ID_CNR_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CNR | 0x1)
#define CMD_ID_CNR_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CNR | 0x2)
#define CMD_ID_CNR_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CNR | 0x3)
#define CMD_ID_CNR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CNR | 0x4)


/* GAMMA  Command */
#define CMD_ID_GAMMA_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GAMMA | 0x1)
#define CMD_ID_GAMMA_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GAMMA | 0x2)
#define CMD_ID_GAMMA_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GAMMA | 0x3)
#define CMD_ID_GAMMA_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GAMMA | 0x4)
#define CMD_ID_GAMMA_SET_GAMMA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GAMMA | 0x5)


/* CS  Command */
#define CMD_ID_CS_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CS | 0x1)
#define CMD_ID_CS_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CS | 0x2)
#define CMD_ID_CS_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CS | 0x3)
#define CMD_ID_CS_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CS | 0x4)


/* FR_SHARPEN  Command */
#define CMD_ID_FR_SHARPEN_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_FR_SHARPEN | 0x1)
#define CMD_ID_FR_SHARPEN_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_FR_SHARPEN | 0x2)
#define CMD_ID_FR_SHARPEN_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_FR_SHARPEN | 0x3)
#define CMD_ID_FR_SHARPEN_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_FR_SHARPEN | 0x4)

/* GE  Command */
#define CMD_ID_GE_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GE | 0x1)
#define CMD_ID_GE_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GE | 0x2)
#define CMD_ID_GE_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GE | 0x3)
#define CMD_ID_GE_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_GE | 0x4)
//


/*  BLS  Command */
#define CMD_ID_BLS_SET_MODE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_BLS | 0x1)
#define CMD_ID_BLS_SET_BLACK_LEVEL \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_BLS | 0x2)
#define CMD_ID_BLS_SET_WINDOW \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_BLS | 0x3)
#define CMD_ID_BLS_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_BLS | 0x4)

/* DEGAMMA  Command */
#define CMD_ID_DEGAMMA_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEGAMMA | 0x1)
#define CMD_ID_DEGAMMA_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEGAMMA | 0x2)
#define CMD_ID_DEGAMMA_SET_CURVE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEGAMMA | 0x3)
#define CMD_ID_DEGAMMA_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_DEGAMMA | 0x4)


/* Frame CTRL  Command */
#define CMD_ID_SEND_FRAME_CTRL \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_FRAME | 0x1)
#define CMD_ID_SEND_FRAME_INFO \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_FRAME | 0x2)

/* Buffer  Command */
#define CMD_ID_SEND_BUFFER \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_BUFFER | 0x1)

/* Dithering Fclip Hflip Command */
#define CMD_ID_DITHERING_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x1)
#define CMD_ID_DITHERING_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x2)
#define CMD_ID_DITHERING_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x3)
#define CMD_ID_FCLIP_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x4)
#define CMD_ID_FCLIP_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x5)
#define CMD_ID_FCLIP_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x6)
#define CMD_ID_HFLIP_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x7)
#define CMD_ID_HFLIP_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x8)
#define CMD_ID_HFLIP_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DITH_FCLIP_HFLIP | 0x9)

/* IE Command */
#define CMD_ID_IE_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_IE | 0x1)
#define CMD_ID_IE_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_IE | 0x2)
#define CMD_ID_IE_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_IE | 0x3)
#define CMD_ID_IE_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_IE | 0x4)

/* YUV NR Command */
#define CMD_ID_YUV_NR_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_YUV_NR | 0x1)
#define CMD_ID_YUV_NR_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_YUV_NR | 0x2)
#define CMD_ID_YUV_NR_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_YUV_NR | 0x3)
#define CMD_ID_YUV_NR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_YUV_NR | 0x4)

/* Sharpen Command */
#define CMD_ID_SHARPEN_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_SHARPEN | 0x1)
#define CMD_ID_SHARPEN_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_SHARPEN | 0x2)
#define CMD_ID_SHARPEN_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_SHARPEN | 0x3)
#define CMD_ID_SHARPEN_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_SHARPEN | 0x4)
#define CMD_ID_SHARPEN_SET_SHARPNESS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_SHARPEN | 0x5)

/* DIR Command */
#define CMD_ID_DIR_CONFIG_PARAM \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x1)
#define CMD_ID_DIR_BPC_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x2)
#define CMD_ID_DIR_BPC_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x3)
#define CMD_ID_DIR_DECON_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x4)
#define CMD_ID_DIR_DECON_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x5)
#define CMD_ID_DIR_CIP_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x6)
#define CMD_ID_DIR_CIP_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x7)
#define CMD_ID_DIR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x8)
#define CMD_ID_DIR_RGB_ADJUST_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0x9)
#define CMD_ID_DIR_RGB_ADJUST_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0xa)
#define CMD_ID_DIR_IR_STREAM_SEL \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DIR | 0xb)

/* PDZZ Command */
#define CMD_ID_PDE_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x1)
#define CMD_ID_PDE_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x2)
#define CMD_ID_PDE_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x3)
#define CMD_ID_PDE_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x4)
#define CMD_ID_PDC_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x5)
#define CMD_ID_PDC_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x6)
#define CMD_ID_PDC_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x7)
#define CMD_ID_PDC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x8)
#define CMD_ID_PDNC_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x9)
#define CMD_ID_PDNC_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xa)
#define CMD_ID_PDNC_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xb)
#define CMD_ID_PDNC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xc)
#define CMD_ID_BPC_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xd)
#define CMD_ID_BPC_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xe)
#define CMD_ID_BPC_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0xf)
#define CMD_ID_BPC_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x10)
#define CMD_ID_PDCIP_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x11)
#define CMD_ID_PDCIP_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x12)
#define CMD_ID_PDCIP_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x13)
#define CMD_ID_PDCIP_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x14)
#define CMD_ID_ZZHDR_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x15)
#define CMD_ID_ZZHDR_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x16)
#define CMD_ID_ZZHDR_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x17)
#define CMD_ID_ZZHDR_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x18)
#define CMD_ID_HBIN_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x19)
#define CMD_ID_HBIN_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x1a)
#define CMD_ID_HBIN_CONFIG \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x1b)
#define CMD_ID_HBIN_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_PDZZ | 0x1c)
#define CMD_ID_DG_ENABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DGHDR | 0x1)
#define CMD_ID_DG_DISABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DGHDR | 0x2)
//
//#define CMD_ID_DG_CONFIG
//	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DGHDR | 0x3)
//#define CMD_ID_DG_GET_STATUS
//	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_DGHDR | 0x4)
//
/*mipi bayer scaler Command*/
#define CMD_ID_SET_BRSZ_TABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_BRSZ  | 0x1)
#define CMD_ID_BRSZ_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_BRSZ  | 0x2)

/* YUV RSZ TABLE Command */
#define CMD_ID_SET_RSZ_TABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_RSZ  | 0x1)
#define CMD_ID_GET_RSZ_TABLE \
	(CMD_TYPE_STREAM_CTRL  | CMD_GROUP_STREAM_RSZ  | 0x2)

/* M2M  Command */
#define CMD_ID_M2M_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_M2M | 0x1)
#define CMD_ID_M2M_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_M2M | 0x2)

//secure case
#define CMD_ID_ENABLE_SECURE_CASE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SECURE | 0x1)
#define CMD_ID_DISABLE_SECURE_CASE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SECURE | 0x2)
#define CMD_ID_SEND_GUID \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_SECURE | 0x3)
/* CRISP Command */
#define CMD_ID_CRISP_VS_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CRISP | 0X01)
#define CMD_ID_CRISP_VS_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CRISP | 0X02)
#define CMD_ID_CRISP_DETECTION_CFG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_CRISP | 0X03)
/* LSC Command */
#define CMD_ID_LSC_SET_STRENGTH \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x1)
#define CMD_ID_LSC_SET_CCT_THRESHOLD \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x2)
#define CMD_ID_LSC_SET_SMOOTH_RATIO \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x3)
#define CMD_ID_LSC_SET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x4)
#define CMD_ID_LSC_GET_TUNING_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x5)
#define CMD_ID_LSC_SET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x6)
#define CMD_ID_LSC_GET_CALIB_DATA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_LSC | 0x7)

/* NonEquilGamm Command */
#define CMD_ID_NONEQUILGAMMA_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_NONEQUILGAMMA | 0x1)
#define CMD_ID_NONEQUILGAMMA_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_NONEQUILGAMMA | 0x2)

/* AutoContrast Command */
#define CMD_ID_AUTOCONTRAST_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AUTOCONTRAST | 0x1)
#define CMD_ID_AUTOCONTRAST_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AUTOCONTRAST | 0x2)
#define CMD_ID_AUTOCONTRAST_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AUTOCONTRAST | 0x3)
#define CMD_ID_AUTOCONTRAST_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_AUTOCONTRAST | 0x4)

/* 3DLut Command */
#define CMD_ID_3DLUT_ENABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_3DLUT | 0x1)
#define CMD_ID_3DLUT_DISABLE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_3DLUT | 0x2)
#define CMD_ID_3DLUT_CONFIG \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_3DLUT | 0x3)
#define CMD_ID_3DLUT_GET_STATUS \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_3DLUT | 0x4)

/* Scene Mode Command */
#define CMD_ID_TDB_SET_PIPELINE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TDB | 0x1)
#define CMD_ID_TDB_GET_PIPELINE \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TDB | 0x2)
#define CMD_ID_TDB_SET_AAA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TDB | 0x3)
#define CMD_ID_TDB_GET_AAA \
	(CMD_TYPE_STREAM_CTRL | CMD_GROUP_STREAM_TDB | 0x4)
/* ------------------------------------------------------------------ */
/*                                   Response ID List                   */
/* ----------------------------------------------------------------     */

/* respId is in the format of following type:
 * |<-Bit31 ~ Bit24->|<-Bit23 ~ Bit16->|<-Bit15 ~ Bit0->|
 * |      0          |      group      |       id       |
 */

#define RESP_GROUP_SHIFT                 (16)
#define RESP_GROUP_MASK                  (0xff << RESP_GROUP_SHIFT)

#define GET_RESP_GROUP_VALUE(respId) \
	((respId & RESP_GROUP_MASK) >> RESP_GROUP_SHIFT)
#define GET_RESP_ID_VALUE(respId)    (respId & 0xffff)

#define RESP_GROUP_GENERAL               (0x1 << RESP_GROUP_SHIFT)
#define RESP_GROUP_ERROR                 (0x2 << RESP_GROUP_SHIFT)
#define RESP_GROUP_SENSOR                (0x3 << RESP_GROUP_SHIFT)
#define RESP_GROUP_LENS                  (0x4 << RESP_GROUP_SHIFT)
#define RESP_GROUP_FLASH                 (0x5 << RESP_GROUP_SHIFT)
#define RESP_GROUP_IMC                   (0x6 << RESP_GROUP_SHIFT)


/* General  Response */
#define RESP_ID_CMD_DONE                            (RESP_GROUP_GENERAL | 0x1)
#define RESP_ID_FRAME_DONE                          (RESP_GROUP_GENERAL | 0x2)
#define RESP_ID_FRAME_INFO                          (RESP_GROUP_GENERAL | 0x3)
#define RESP_ID_ERROR                               (RESP_GROUP_GENERAL | 0x4)

/* Sensor  Response */
#define RESP_ID_SENSOR_GROUP_HOLD                   (RESP_GROUP_SENSOR | 0x1)
#define RESP_ID_SENSOR_GROUP_RELEASE                (RESP_GROUP_SENSOR | 0x2)
#define RESP_ID_SENSOR_SET_AGAIN                    (RESP_GROUP_SENSOR | 0x3)
#define RESP_ID_SENSOR_SET_DGAIN                    (RESP_GROUP_SENSOR | 0x4)
#define RESP_ID_SENSOR_SET_ITIME                    (RESP_GROUP_SENSOR | 0x5)
#define RESP_ID_SENSOR_SET_HDR_HIGH_ITIME           (RESP_GROUP_SENSOR | 0x6)
#define RESP_ID_SENSOR_SET_HDR_LOW_ITIME            (RESP_GROUP_SENSOR | 0x7)
#define RESP_ID_SENSOR_SET_HDR_LOW_ITIME_RATIO      (RESP_GROUP_SENSOR | 0x8)
#define RESP_ID_SENSOR_SET_HDR_EQUAL_ITIME          (RESP_GROUP_SENSOR | 0x9)
#define RESP_ID_SENSOR_SET_HDR_HIGH_AGAIN           (RESP_GROUP_SENSOR | 0xa)
#define RESP_ID_SENSOR_SET_HDR_LOW_AGAIN            (RESP_GROUP_SENSOR | 0xb)
#define RESP_ID_SENSOR_SET_HDR_LOW_AGAIN_RATIO      (RESP_GROUP_SENSOR | 0xc)
#define RESP_ID_SENSOR_SET_HDR_EQUAL_AGAIN          (RESP_GROUP_SENSOR | 0xd)
#define RESP_ID_SENSOR_SET_HDR_HIGH_DGAIN           (RESP_GROUP_SENSOR | 0xe)
#define RESP_ID_SENSOR_SET_HDR_LOW_DGAIN            (RESP_GROUP_SENSOR | 0xf)
#define RESP_ID_SENSOR_SET_HDR_LOW_DGAIN_RATIO      (RESP_GROUP_SENSOR | 0x10)
#define RESP_ID_SENSOR_SET_HDR_EQUAL_DGAIN          (RESP_GROUP_SENSOR | 0x11)

/* Lens  Response */
#define RESP_ID_LENS_SET_POS                        (RESP_GROUP_LENS | 0x1)

///* Flash  Resonse */
//#define RESP_ID_FLASH_SET_POWER                   (RESP_GROUP_FLASH | 0x1)
//#define RESP_ID_FLASH_SET_ON                      (RESP_GROUP_FLASH | 0x2)
//#define RESP_ID_FLASH_SET_OFF                     (RESP_GROUP_FLASH | 0x3)

#define RESP_ID_IMC_CAM_RESET_REQ                     (RESP_GROUP_IMC | 0x1)
#define RESP_ID_IMC_CAM_RESET_RECOVERY                (RESP_GROUP_IMC | 0x2)
#define RESP_ID_IMC_WAIT_CVIP_ACK_OVERTIME            (RESP_GROUP_IMC | 0x3)
#define RESP_ID_IMC_WAIT_CVIP_IN_IMAGE_OVERTIME       (RESP_GROUP_IMC | 0x4)

/* For fw rb log usage */
#define FW_LOG_RB_SIZE_REG mmISP_LOG_RB_SIZE
#define FW_LOG_RB_RPTR_REG mmISP_LOG_RB_RPTR
#define FW_LOG_RB_WPTR_REG mmISP_LOG_RB_WPTR
#define FW_LOG_RB_BASE_LO_REG mmISP_LOG_RB_BASE_LO
#define FW_LOG_RB_BASE_HI_REG mmISP_LOG_RB_BASE_HI


/* -----------------------------------------------------------------*/
/*                                   Command Param List                    */
/* -----------------------------------------------------------------*/



//--------------------------------------------------------------------
//                                            Global CTRL Command
//--------------------------------------------------------------------

/*
 * Each command is detailed in the following columns:
 *
 * CMD_ID_XXX:      The id fo the corresponding command.
 *
 * CmdChannel:      Specify which command channel host should send this kind
 *                  command. "NonBlock" means this kind
 *                  command should be push into the NonBlock command channel.
 *                  "StreamX" means this kind is stream related
 *                  command and should push into the corresponding stream
 *                  command channel for which host want to CTRL.
 *
 * RespChannel:    Specify which response channel the RESP_ID_CMD_DONE respone
 *                  for this command is returned.
 *                  "Global" means it is returned in the global response
 *                  channel. "StreamX" means it is returned in the
 *                  corresponding stream response channel, which the X for
 *                  command and response should be same. X can be
 *                  1, 2, 3 for the three defined streams.
 *
 * ParameterType:   How the command parameter is included. "Direct" means the
 *                  command parameter is stored in the
 * cmdParam field in the struct _Cmd_t structure. "Indirect" means the
 *                  command parameter is in another buffer. The
 *                  buffer address, size and checksum is specified in a struct
 *                  of struct _CmdParamPackage_t. The CmdParamPackage
 *   is stored in the cmdParam field in the struct _Cmd_t structure.
 *
 * Parameter:       The command parameter definition for the specified command.
 *
 * Description:     A detail description for the specified command
 *
 * Type:            Defined when the command can send. "Static" means the
 *                  command can only be send when the firmware state
 *                  for of the command to set/get is not in used. "Dynamic"
 *                  means the command can be send at any time when
 *                  host want to change the state. Detail information can refer
 *                  to the Description section.
 *
 * ResponsePayload:Each host command will get a RESP_ID_CMD_DONE response from
 *                  firmware.
 *                  The ResponsePayload defined the payload in the
 *                  RESP_ID_CMD_DONE response for this command.
 *
 * ResponseTime:    When the RESP_ID_CMD_DONE response will be send back to
 *                  host. "Processed" means the
 *                  response will be send back after the command was processed.
 *                  "Enqueued" means the respsone will be
 *                  send back after firmware parsed the command and enqueued it
 *                  into its internal queue. Host should check
 *                  the meta data information in RESP_ID_FRAME_DONE response to
 *                  confirm which frame the new state is
 *                  applied.
 */





//General Command
//---------------


//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GET_FW_VERSION
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used for host to get the current firmware
//             version. The value will be
//returned by the response payload. Version is an unsigned int number
//             in the format of:
//             Bit31 to Bit24 is the major version, Bit23 to Bit16 is the minor
//             version, Bit15 to Bit0 is the revision number.
//             The first version is 0x02000000, that is 2.0.0. Any bug fix will
//             increase the revision number and any function
//             added will increase the minor number and reset the revision to 0.
//              The major number will only increase in a big
//             change of the firmware. Host can send this command at any time
//             after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: unsigned int version
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PREPARE_CHANGE_ICLK
// @CmdChannel: nonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: none
// @Description: This command will be sent before HOST change the ICLK to inform
//               firmware to do some preparing work(e.g. skip
//               AF/AE, reset timer, etc.), host can change the ICLK after FW
//               response this command.
//               NOTE: later host must send CMD_ID_SET_CLK_INFO to tell firmware
//               that clock change has finished.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_CLK_INFO
// @CmdChannel: nonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSetClkInfo_t {
	unsigned int sclk;   //In KHz
	unsigned int iclk;   //In KHz
	unsigned int refClk; //In KHz
};
// @Description: This command send the current isp running clock information to
//               firmware. Firmware may use
//             these clock information to calculate the profiler and flash timer
//               count. So, these information should be
//             exactly the hardware running clock. Or some CTRL may fail.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @page CMD_ID_CONFIG_MMHUB_PREFETCH
// @verbatim
// CmdId: CMD_ID_CONFIG_MMHUB_PREFETCH
// CmdChannel: nonBlock
// RespChannel: Global
// ParameterType: Direct
// Parameter: _CmdConfigMmhubPrefetch_t
// Description: This command is used to enable/disable MMHUB prefetch function.
//         bEnStg1 is for MIPI stage WDMA prefetch function.
//         bEnStg2 is for all ISP stage WDMA prefetch function, it includes
//	   TNR WDMA, SI WDMA also.
//         bEnPerf is for MMHUB performance monitor function, it will print
//         hit/miss count in FW log if enabled.
//         bAddGapForYuv is for that use case, The Yuv outbuf sent by Host
//         can't meet prefetch requirement:
//                            1.Start/End Addr aligned to 32K.
//                            2.Buffer Size is aligned to 32K.
//                            3.There is at least 32K gap between Y U V planar
//                            FW will forcely align the start/end address
//                            to 32K and add 32K Gap between Y U V planars
//                            before programming prefetch registers.
// Type: Dynamic
// ResponsePayload: None
// ResponseTime: Processed
// @endverbatim
//  @struct _CmdConfigMmhubPrefetch_t
//  Parameter of CMD_ID_CONFIG_MMHUB_PREFETCH
struct _CmdConfigMmhubPrefetch_t {
	int bEnStg1;   ///< bEnStg1
	int bEnStg2;   ///< bEnStg2
	int bEnPerf;   ///< bEnPerf
	int bAddGapForYuv;   ///< bAddGapForYuv
};

//Debug Command
//-------------


//+++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_READ_REG
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdReadReg_t {
	unsigned int regAddr;
};
// @Description: This command is used to ask firmware to read a register value.
//               The result value will be send
//               back to host by response. This command can be send at any time
//               after firmware is boot up.
// @Type: Dynamic
// @ResponsePayload:
struct _RegValue_t {
	unsigned int regAddr;
	unsigned int regValue;
};
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++




//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_WRITE_REG
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdWriteReg_t {
	unsigned int regAddr;
	unsigned int regValue;
};
// @Description: This command is used to ask firmware to write a register value.
//               Firmware will send the
//             RESP_ID_CMD_DONE response to host after this command is
//               processed. This command can be send at
//             any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LOG_SET_LEVEL
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdLogSetLevel_t {
	enum _LogLevel_t level;
};
// @Description: This command is used to set the firmware log level in debug
//               mode. This command can be send
//             at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LOG_ENABLE_MOD
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdLogEnableMod_t {
	enum _ModId_t mod;
};
// @Description: This command is used to enable a specific module to dump log.
//               All module log are enabled
//             by default. This command can be send at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++



//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LOG_DISABLE_MOD
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdLogDisableMod_t {
	enum _ModId_t mod;
};

// @Description: This command is used to disable a specific module's log dump.
//               It can be send at any time after
//             the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++



//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_LOG_MOD_EXT
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
// level_bits[i]
// i = 0 : Bit map 0 for log level of FW modules. 4 bits represent one
//               FW modules. Bit[4*(mod_id - 1) ~ (4*mod_id-1)] represents
//               FW module refers to mod_id , When 1 <= mod_id <= 8.
// i = 1 : Bit map 1 for log level of FW modules. 4 bits represent one
//               FW modules. Bit[4*(mod_id - 9) ~ (4*(mod_id - 9)+3)]
//               represents FW module refers to mod_id , When 9 <= mod_id <= 16.
// i = 2 : Bit map 2 for log level of FW modules. 4 bits represent one
//               FW modules. Bit[4*(mod_id - 17) ~ (4*(mod_id - 17)+3)]
//               represents FW module refers to mod_id , When 17 <= mod_id <= 24
// i = 3 : Bit map 3 for log level of FW modules. 4 bits represent one
//               FW modules. Bit[4*(mod_id - 25) ~ (4*(mod_id - 25) +3)]
//               represents FW module refers to mod_id , When 25 < mod_id <= 32.
// i = 4 : Bit map 4 for log level of FW modules. 4 bits represent one
//               FW modules. Bit[4*(mod_id - 33) ~ (4*(mod_id - 33)+3)]
//               represents FW module refers to mod_id , When 33 <= mod_id <= 40


#define LOG_EXT_NUM    ((MOD_ID_MAX + 7) / 8)
struct _CmdSetLogModExt_t {
	unsigned int level_bits[LOG_EXT_NUM];
	//unsigned int level_bits_A;
	//unsigned int level_bits_B;
	//unsigned int level_bits_C;
	//unsigned int level_bits_D;
	//unsigned int level_bits_E;
};

// @Description: This command is used to set specific module's log dump at
//               specific log levels(0~5). It can be sent at any time after
//		 the firmware is boot up. This extend log command can't be used
//               with old log commands together for avoiding log level setting
//               conflict.
//               Currently, There are 33 FW modules and mod_ids are  defined in
//    enum _ModId_t.
//There are 5 log levels that are defined in enum _LogLevel_t.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PROFILER_GET_RESULT
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
// @Description: This command is used to get the current profiler result.
//               It is used for debug purpouse. The
//             results will be written to the buffer specified in the
//               CmdProfilerGetResult _t. The result is a struct
//             of ProfilerResult_t.
//This command can be send at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: BufCheckSum_t.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GET_ALL_TASK_STATS
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
// @Description: This command is used to get all tasks' statistics data, each
//               task's statistics data
//               was described by OneTaskStats_t.
//               The results will be written to the buffer specified in the
//               CmdGetAllTasksStats_t.
//               User should make sure the buffer size is enough to store all
//               tasks' data.
//               FW will make sure the strlen(taskName) > 0.
//This command can be send at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: BufCheckSum_t with the actual used buffer size.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//Sensor Related Command
//----------------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_PROP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetSensorProp_t {
	enum _SensorId_t sensorId;
	struct _SensorProp_t sensorProp;
};
// @Description: This command is used to set a sensor property for the specified
//               sensor denoted by sensorId.
//           The information will be used to setup the isp pipeline input
//               interface when one stream is started from its related
//           sensor. So, this command must be send before starting a stream and
//               can't be changed after the stream is
//           started.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_HDR_PROP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetSensorHdrProp_t {
	enum _SensorId_t sensorId;
	struct _SensorHdrProp_t hdrProp;
};
// @Description: This command is used to set a sensor hdr property for the
//               specified sensor denoted by
//             sensorId. This command must be send before enable hdr and can't
//               be changed after the hdr is
//             started.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_PD_PROP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetSensorPdProp_t {
	enum _SensorId_t sensorId;
	struct _SensorPdProp_t pdProp;
};
// @Description: This command is used to set a sensor pd property for the
//               specified sensor denoted by
//             sensorId. This command is used to send mipi pdx configure info.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_SLICE_NUM
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSetSensorSliceNum_t {
	enum _SensorId_t sensorId;
	unsigned int     sliceNum;
};
// @Description: This command is used to set a sensor slice number before start
//               streaming
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_EMB_PROP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetSensorEmbProp_t {
	enum _SensorId_t sensorId;
	struct _SensorEmbProp_t embProp;
};
// @Description: This command is used to set a sensor emb property for the
//               specified sensor denoted by
//             sensorId. This command must be send before enable emb and can't
//               be changed after the emb is
//             started.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_SENSOR_CALIBDB
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSetSensorCalibdb_t {
	enum _StreamId_t streamId;
	unsigned char tdbIdx;	   // from 0 to max support of one stream
	unsigned int width;
	unsigned int height;
	unsigned int  fps;       ///< fps according to sensor profile
	///< expo limit according to max itime of tuning data
	enum _TdbSwitchExpoLimit_t  expoLimit;
	unsigned int bufAddrLo;  //Low 32bit address of the calibration data
	unsigned int bufAddrHi;  //High 32bit address of the calibration data
	unsigned int bufSize;    //calibration data buffer size
	unsigned char  checkSum;   //The byte sum of the calibration data.
};
// @Description: This command set the calibration data for
//the specified sensor. It should be sent before starting
//a stream with the calibration data enabled and can't be sent
//after a stream from this sensor is on streaming.
//the value for tdbIdx should only be 0,1,2; width
//and height is according tuning data binary
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_UPDATE_SENSOR_CALIBDB
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdUpdateSensorCalibdb_t {
	enum _StreamId_t streamId;
	unsigned char tdbIdx;	   // from 0 to 2
	unsigned int width;
	unsigned int height;
	unsigned int fps;        ///< fps
	unsigned int bufAddrLo;  //Low 32bit address of the calibration data
	unsigned int bufAddrHi;  //High 32bit address of the calibration data
	unsigned int bufSize;    //calibration data buffer size
	unsigned char  checkSum;   //The byte sum of the calibration data.
};
// @Description: This command update the calibration data for the
//sensor. When send this cmd, pleae make sure current
//tdbIdx havn't been use now for FW, if it's
//current using, the update will failed
//the value for tdbIdx should only be 0,1,2; width
//and height is according tuning data binary
//This CMD only can update the calibration data which you have
//set and enabled before.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_CVIP_LENS_SWEEP_PARAM
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
//struct _CmdSetLensSweepParam_t {
//	enum _SensorId_t	sensorId;
//	enum _SweepMode_t	mode;
//	float	sweepDistanceNear;
//	float	sweepDistanceFar;
//	unsigned int	stepCount;
//	unsigned int	frameDwellCount;
//};

// @Description: This command is used to set dynamic parameters
// for sweep mode for CVIP sensor
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_START_CVIP_LENS_SWEEP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
//struct _CmdStartCvipLensSweep_t {
//	enum _SensorId_t sensorId;
//};

// @Description: This command is used to start sweep mode for CVIP sensor
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_STOP_CVIP_LENS_SWEEP
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
//struct _CmdStopCvipLensSweep_t {
//	enum _SensorId_t sensorId;
//};

// @Description: This command is used to stop sweep mode for CVIP sensor
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++


//Device CTRL Command
//----------------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_DEVICE_CTRL_MODE
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSetDeviceCtrlMode_t {
	enum _SensorId_t sensorId;
	enum _DeviceControlMode_t mode;
};
// @Description: This command is used to set the device control mode for the
//               specified sensor,
// @Type: Static
// @ResponsePayload: None
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_DEVICE_SCRIPT
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetDeviceScript_t {
	enum _SensorId_t sensorId;
	struct _DeviceScript_t deviceScript;
};
// @Description: This command is used to set the device script for the specified
//               sensor with sensor, flash,
//             lens CTRL, etc. It can only be send when the device script CTRL
//               is not enabled.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_GROUP_HOLD
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorGroupHold_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to acknowledge the
//               RESP_ID_SENSOR_GROUP_HOLD response.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_GROUP_RELEASE
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorGroupRelease_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to acknowledge the
//               RESP_ID_SENSOR_GROUP_RELEASE response.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_AGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetAGain_t {
	enum _SensorId_t sensorId;
	unsigned int aGain;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_SENSOR_SET_AGAIN to
//             firmware.The aGain is the result analog gain set into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_DGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetDGain_t {
	enum _SensorId_t sensorId;
	unsigned int dGain;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_SENSOR_SET_DGAIN to
//             firmware. The dGain is the result digital gain set
//               into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_ITIME
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_SENSOR_SET_ITIME to
//             firmware. The itime is the result itime set into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_HIGH_ITIME
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrHighItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_HIGH_ITIME to firmware. The itime is the
//               result high itime set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_ITIME
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_ITIME to firmware. The itime is the
//               result low itime set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_ITIME_RATIO
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowItimeRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_ITIME_RATIO  to firmware. The ratio
//               is the result low itime ratio set
//             into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_ITIME
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrEqualItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_EQUAL_ITIME  to firmware. The itime is
//               the result equal itime set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_HIGH_AGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrHighAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_HIGH_AGAIN to firmware. The aGain is the
//               result high analog gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_AGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_AGAIN to firmware. The aGain is the
//               result low analog gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_AGAIN_RATIO
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowAGainRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_AGAIN_RATIO  to firmware. The ratio
//               is the result low analog gain ratio set
//             into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_AGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrEqualAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @DescriptionThis command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_EQUAL_AGAIN  to firmware. The aGain is
//               the result equal analog gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++





//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_HIGH_DGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrHighDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_HIGH_DGAIN to firmware.The gain is the
//               result high digital gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_DGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_DGAIN to firmware. The gain is the
//               result low digital gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_LOW_DGAIN_RATIO
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrLowDGainRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_LOW_DGAIN_RATIO  to firmware.The ratio
//               is the result low gain ratio set
//             into the sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_SENSOR_SET_HDR_EQUAL_DGAIN
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckSensorSetHdrEqualDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain;
};
// @Description: This command is used to acknowledge the response
//             RESP_ID_SENSOR_SET_HDR_EQUAL_DGAIN  to firmware. The gain is
//               the result equal digital gain set into the
//             sensor.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_LENS_SET_POS
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckLensSetPos_t {
	enum _SensorId_t sensorId;
	unsigned int lensPos;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_LENS_SET_POS to firmware.
//             The lensPos is the result lens set into the lens drive.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_FLASH_SET_POWER
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckFlashSetPower_t {
	enum _SensorId_t sensorId;
	unsigned int powerLevel;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_FLASH_SET_POWER to
//            firmware. The powerLevel is the result power level set
//               into the flash.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_FLASH_SET_ON
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckFlashSetOn_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_FLASH_SET_ON to firmware.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ACK_FLASH_SET_OFF
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdAckFlashSetOff_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to acknowledge the response
//               RESP_ID_FLASH_SET_OFF to firmware.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//I2C CTRL Command
//-------------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_I2C_MSG
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSendI2cMsg_t {
	enum _I2cDeviceId_t deviceId;
	struct _I2cMsg_t msg;
};
// @Description: This command is used for host to CTRL external
//               i2c device through firmware after the
//             firmware is started.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//Clock and Power CTRL Command
//-------------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ENABLE_CLOCK_GATING
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used for host to enable FW clock gating CTRL
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DISABLE_CLOCK_GATING
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used for host to disable FW clock gating CTRL
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ENABLE_POWER_GATING
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used for host to enable FW power
//               gating CTRL (of Tile B)
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DISABLE_POWER_GATING
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used for host to disable FW power
//               gating CTRL (of Tile B)
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
//                                            Stream CTRL Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
//General Command
//---------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_STREAM_PATH
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetStreamPath_t {
	struct _StreamPathCfg_t pathCfg;
};
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_INPUT_SENSOR
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetInputSensor_t {
	enum _SensorId_t sensorId;
};
// @Description: This command set the input sensor for the stream. This command
//               should be sent before the
//             start streaming command.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_BRSZ_TABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdSetBrszTable_t {
	struct _BrszTable_t brszTable;
};
// @Description: This command set mipi bayer scaler table to fw for the stream.
//               This command can be send at any time after firmware boot up.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_BRSZ_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command get mipi bayer scaler status include enable and
//               window size for the stream. This command can be send at any
//               time after firmware boot up.
// @Type: Static
// @ResponsePayload:
struct _CmdGetBrszStatus_t {
	struct _MipiBrszStatus_t mipiBrszStatus;
};
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_ACQ_WINDOW
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetAcqWindow_t {
	struct _Window_t window;
};
// @Description: This command set the isp input acqisitioin window. This window
//               should be in the range of the
//             sensor output resolution.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ENABLE_CALIB
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdEnableSensorCalibdb_t {
	unsigned char enableMask;
};
// @Description: This command is used to enable the calibration data usage for
//               the stream. By default the
//             calibration data is disabled in firmware. Host should send this
//               command after the
//             CMD_ID_SET_SENSOR_CALIB and setup the input sensor
//               by CMD_ID_SET_INPUT_SENSOR to enable
//             the calibration. It will initial the 3A parameters
//               from the calibration data.
//			   enableMask use bit to indicate to enable which
//               tdb, as below shows
//			   if enable tdb 0 so enableMask | = TDB_IDX_0;
//			   #define TDB_IDX_0                (0x1 << 0)
//			   #define TDB_IDX_1                (0x1 << 1)
//             #define TDB_IDX_2                (0x1 << 2)

// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DISABLE_CALIB
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDisableSensorCalibdb_t {
	unsigned char disableMask;
};

// @Description: This command is used to disable the calibration data usage for
//               the stream. It will reset the 3A
//             parameters to default values.
//			   disMask use bit to indicate to disable which tdb, as
//               below shows
//			   if disable tdb 0 so disableMask | = TDB_IDX_0;
//			   #define TDB_IDX_0                (0x1 << 0)
//			   #define TDB_IDX_1                (0x1 << 1)
//             #define TDB_IDX_2                (0x1 << 2)
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_ASPECT_RATIO_WINDOW
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetAspectRatioWindow_t {
	struct _Window_t window;
};
// @Description: This command is used to set the aspect ratio window to keep
//               aspect ratio. The aspect window
//             is cropped from the sensor acquisition window. This window is
//               added in order to keep aspect ratio without to
//             change the sensor acquisition window which need a corresponding
//               calibration data. The default window is
//             equal to the sensor acquisition window.  This command can only
//               be send in stream idle status.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_ZOOM_WINDOW
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetZoomWindow_t {
	struct _Window_t window;
};

struct _CmdSetYuvResizeZoomWindow_t {
	enum _WindowType_t windowType;
	struct _Window_t window;
};

// @Description: This command is used to set the zoom window for the stream.
//               The zoom window is cropped
//             from the aspect ratio window. This command can be send at any
//               time after firmware boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdSetIRIlluConfig_t {
	struct _IRIlluConfig_t IRIlluConfig;
};

////+++++++++++++++++++++++++++++++++++++++++++++++++
//// @CmdId: CMD_ID_SET_CSM_YUV_RANGE
//// @CmdChannel: StreamX
//// @RespChannel: StreamX
//// @ParameterType: Direct
//// @Parameter:
//struct _CmdSetCsmYuvRange_t
//{
//    CSMYUVRange_t CsmYuvRange;
//}CmdSetCsmYuvRange_t;
//// @Description: This command is used to set CSM YUV Range
//// @Type: Dynamic
//// @ResponsePayload: None
//// @ResponseTime: Processed
////++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_DIR_OUTPUT_FRAME_TYPE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetDirOutputFrameType_t {
	enum _FrameType_t frameType;
};
// @Description: This command is used to set pipeline stage 2 output frame type
// with RGB-IR input. The output frame type can be RGB bayer or IR.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_OUT_CH_PROP
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetOutChProp_t {
	enum _IspPipeOutCh_t ch;
	struct _ImageProp_t imageProp;
};
// @Description: This command set the image output property for the isp pipe
//               channel of the stream. Host can
//             send this command only when the path is not enabled or the
//               stream is totally idle. That means it is safety to
//             send this command after firmwar boot up but before start
//               streaming. When the stream is started and the
//             path output channel is not enabled, it is also safety to
//               send this command.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_OUT_CH_FRAME_RATE_RATIO
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetOutChFrameRateRatio_t {
	enum _IspPipeOutCh_t ch;
	unsigned int ratio;
};
// @Description: This command set the isp pipe frame rate ratio with the input
//               sensor frame rate. The default ratio
//             is 1. Allowed values are: 1~30. The output frame rate of the
//               isp pipe channel is: 1/ratio * SensorFrameRate.
//             Host can send this command only when the zsl is not enabled
//               or the stream is totally idle. That means it is
//             safety to send this command after firmwar boot up but before
//               start streaming. When the stream is started and
//             the isp pipe output channel is not enabled, it is also safety
//               to send this command.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ENABLE_OUT_CH
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdEnableOutCh_t {
	enum _IspPipeOutCh_t ch;
};
// @Description: This command is used to enable the isp pipe output for the
//               stream. Host should set the isp pipe
//             output property and zsl buffer queue before send this command
//               when it is in streaming status. If the
//             streaming is not started, this command can send at any time.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DISABLE_OUT_CH
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDisableOutCh_t {
	enum _IspPipeOutCh_t ch;
};
// @Description: This command is used to disable the isp pipe output for the
//               stream. By default, the isp pipe output
//             is disabled. This command can be send at any time after firmware
//               boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAPTURE_YUV
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdCaptureYuv_t {
	struct _ImageProp_t imageProp;
	struct _Buffer_t buffer;
};
// @Description: This command is used to capture a yuv picture from the zsl
//               channel. The image format and
//             resolution are specified in the imageProp fieleds. The meata
//               data and buffer will be returned in the
//             RESP_ID_FRAME_DONE respone. The frame with this buffer will use
//               the precapture measuring
//             result to CTRL the sensor and flash if the usePreCap is set to
//               true. Host should make sure this command
//             is send after CMD_ID_AE_PRECAUTRE command, otherwise the exposure
//               parameter may error. If the usePreCap
//             flag is set to false, the frame with this buffer will use normal
//               3A to calculate the sensor/flash/lens
//             parameters.
//             Firmware will send this response after the buffer is filled .
//               Host should wait the RESP_ID_FRAME_DONE
//             response to get the buffer capture done signal.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAPTURE_RAW
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCaptureRaw_t {
	int   bNeedFull;
	struct _Buffer_t buffer;
};
// @Description: This command is used to capture a yuv picture from the zsl
//               channel. The image format and
//             resolution are specified in the imageProp fieleds. The meata
//               data and buffer will be returned in the
//             RESP_ID_FRAME_DONE respone. The frame with this buffer will
//               use the precapture measuring
//             result to CTRL the sensor and flash if the usePreCap is set
//               to true. Host should make sure this command
//          is send after CMD_ID_AE_PRECAUTRE command, otherwise the exposure
//               parameter may error. If the usePreCap
//             flag is set to false, the frame with this buffer will use normal
//               3A to calculate the sensor/flash/lens
//             parameters.
//             Firmware will send this response after the buffer is filled .
//               Host should wait the RESP_ID_FRAME_DONE
//             response to get the buffer capture done signal.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAPTURE_FULL_YUV
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdCaptureFullYuv_t {
	enum _CaptureFullYuvType_t    captureType;
	struct _ImageProp_t             imageProp;
	struct _Buffer_t                buffer;
};
// @Description: This command is used to capture a yuv picture from the still
//               full channel.
//             The input raw is full size raw from channel 1. The image format
//               and
//             resolution are specified in the imageProp fieleds.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_LOOPBACK_CFA_PATTERN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetLoopbackCfaPattern_t {
	enum _CFAPattern_t cfaPattern;
};
// @Description: This command is used to set the cfaPattern for loopback stream
//               before start streaming.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_LOOPBACK_PDAF_TYPE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetLoopbackPdafType_t {
	enum _PdafType_t pdafType;
};
// @Description: This command is used to set the PdafType for loopback stream
//               before start streaming.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GET_TOP_BYPASS_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current topBypass setting.
// @Type: Dynamic
// @ResponsePayload: DynamicDPCParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_RAW_PKT_FMT
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetRawPktFmt_t {
	enum _RawPktFmt_t rawPktFmt;
};
// @Description: This command is used to set the raw output format for the
//               stream. See the RawPktFmt_t definition for detail
//               description. The default setting is RAW_PKT_FMT_0.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_START_STREAM
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command starts the stream for the corresponding stream.
//               The Image output property,
//              Input sensor, sensor property, sensor calibration data, image
//               buffers, etc should be ready for this stream.
// @Type: Static
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_STOP_STREAM
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdStopStream_t {
	int destroyBuffers;
};
// @Description: This command stops the stream for the corresponding stream.
//               All the resource will be
//             released after the command response send back to host if the
//               destroyBuffers is set to true. However, the
//             stream context is not reset. Host can speed warm start the
//               stream again if the setting is not changed.  Host
//             should waiting the response back before sending any other
//               command for a next start stream.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IGNORE_META
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdIgnoreMeta_t {
	int ignore;
};
// @Description: This command decides if continue stage2 process when there
//               is no metadata buffer, setting ignore to 1 means
//                      go on even without metabuffer
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_RESET_STREAM
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to reset the stream context to default
//               values. Host can send this
//             command to reset context after CMD_ID_STOP_STREAM if it
//               doesn't need warm start up.
// @Type: Static
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_FRAME_RATE_INFO
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetFrameRateInfo_t {
	unsigned int frameRate; //Actual framerate multiplied by 1000
};
// @Description: This command set the current fixed frame rate information for
//               Ae, Af, Awb to calculate the loop
//             parameters . If the itime range is defined in AFPS mode and the
//               current itime shows the frame rate is lower
//             than this frameRate shows, the itime will
//               be used as the reference.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_FRAME_CTRL_RATIO
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSetFrameCtrlRatio_t {
	unsigned int ratio;
};
// @Description: This s command set the frame rate ratio with the input sensor
//               frame rate to process the frame
//             CTRL command CMD_ID_SEND_FRAME_CTRL. The default ratio is 1.
//               Allowed values are: 1~30.
//             The frame rate to process the frame CTRL command is: 1/ratio
//               * SensorFrameRate.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//AE Command
//----------


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetMode_t {
	enum _AeMode_t mode;
};
// @Description: This command change the AE run mode for the stream. The
//               default mode is AE_MODE_AUTO.
//               Host can send this command at any time to change the current
//               ae mode after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current ae algorithm status.
//               It is used for debug/tuning purpouse.
//               The results will be written to the buffer specified in the
//               struct _CmdParamPackage_t.
//               The result is a struct defined as follows:
struct _AeStatus_t {
	struct _AeCtrlInfo_t aeCtrlInfo;//<AE control info
	struct _FrameExpInfo_t aeExpInfo;//<AE sensor exposure/gain info
};
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_LOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeLock_t {
	enum _LockType_t lockType;
};
// @Description: This command is used to do lock operation on the AE
//               algorithm.
//               The LOCK_TYPE_IMMEDIATELY will lock the AE algorithm
//               immediately, no matter what the AE status now.
//               The LOCK_TYPE_CONVERGENCE will lock the AE algorithm
//               after the ae get to the convergence status.
//               Host can send this command at any time to lock AE after
//               the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_UNLOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to unlock the AE algorithm which is
//               locked by the previous lock
//               command. Host can send this command at any time to unlock
//               AE after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_REGION
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the AE measurement region of the
//               corresponding stream.
//               The input is the struct AaaRegion_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_FLICKER
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetFlicker_t {
	enum _AeFlickerType_t flickerType;
};
// @Description: This command changes the flicker status for AE algorithm of
//               the corresponding stream.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ANALOG_GAIN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetAnalogGain_t {
	unsigned int aGain;
};
// @Description: This command changes the sensor analog gain for the
//               corresponding stream. The AE mode
//               should be in manual mode when send this command in streaming
//               status. When the streaming is in idle
//               status, this command is used to set the initial AE analog gain
//               of auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_DITIGAL_GAIN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetDigitalGain_t {
	unsigned int dGain;
};
// @Description: This command changes the sensor digital gain for the
//               corresponding stream.
//               The AE mode should be in manual mode when send this command
//               in streaming status.
//               When the streaming is in idle status, this command is used
//               to set the initial AE digital gain of auto mode.
//               FW reserve this command and all sensor digital gain is
//               always 1.0x
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ISP_GAIN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetIspGain_t {
	unsigned int ispGain;
};
// @Description: This command changes the sensor ISP gain for the corresponding
//               stream.
//               The AE mode should be in manual mode when send this command
//               in streaming status.
//               When the streaming is in idle status, this command is used
//               to set the initial AE digital gain of auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ITIME
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetItime_t {
	unsigned int itime;
};
// @Description: This command changes the sensor integration time for the
//               corresponding stream.
//               The AE mode should be in manual mode when send this command
//               in streaming status.
//               When the streaming is in idle status, this command is used to
//               set the initial AE integration time of auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_BV
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetEv_t {
	int ev;
};
//               The AE mode should be in manual mode when send this
//               command in streaming status.
//               When the streaming is in idle status, this command is
//               used to set the initial AE integration time of auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ISO_PRIORITY
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetIsoPriority_t {
	unsigned int iso;
};
// @Description: This command is used to set the ISO as a priority of PLine
//               process.
//               Firmware set 0 as the default value, i.e. no ISO priority.
//               Other values cause that PLine converts a fix gain according
//               the ISO value.
//               AE may clip the ISO value according to the minimum saturation
//               gain and the max gain of PLine.
//               This command does not work if AE is manual mode,
//               CMD_ID_AE_SET_ANALOG_GAIN and CMD_ID_AE_SET_ISP_GAIN
//               determin the real gain in manual mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ITIME_PRIORITY
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetItimePriority_t {
	unsigned int itime;
};
// @Description: This command is used to set a fixed itime.
// Firmware may clip the setting according to
// the PLine or real HW limitation (via sensor property).
// This command works in both auto/manual mode.
// @Type: Dynamic
// @ResponsePayload:
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_EV_COMPENSATION
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetEvCompensation_t {
	struct _AeEv_t ev;
};
// @Description: This command set the EV compensation for the AE auto
//               algorithm. The default EV is 0.
//               This parameter only take effects on auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_PRECAPTURE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command trigs a precapture metering according to the
//               current flash and ae mode setting.
//             It is only accept in auto mode.The metering result will be
//               recorded for the usage of the next capture
//             command.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_FPS_RANGE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: Range_t
// @Description: This command is used to set the range of frame rate by
//               cacluating the integration time of sensor.
//               Firmware many clip the range according to the PLine and
//               real sensor limitation (via sensor property).
//               This command works in auto mode only,
//               CMD_ID_AE_SET_ITIME determin the real gain in manual mode.
//               The value scale of FPS is defined as
//               FPS_RANGE_SCALE_FACTOR (i.e 30000 means 30FPS).
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ISO_RANGE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: Range_t
// @Description: This command is used to set the range of ISO, including the
//               analog, digital and ISP gain.
//               Firmware set the default range according to the PLine and
//               real HW limitation (via sensor property).
//               This command works in auto mode only.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_ITIME_RANGE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: Range_t
// @Description: This command is used to set the range of
//               integration time of sensor.
//               Firmware set the default range according to
//               the PLine and real
//               sensor limitation (via sensor property).
//               This command works in auto mode only,
//               CMD_ID_AE_SET_ITIME
//               determin the real gain in manual mode.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_AE_ENABLE_HDR
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to enable the hdr. By default the hdr
//               is disabled.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_DISABLE_HDR
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to disable the hdr.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command assigns AE tuning data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _ae_tuning_param_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_GET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command get current AE tuning data and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _ae_tuning_param_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command assigns AE calibration data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _ae_calibration_param_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_GET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command get current AE calibration data  and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _ae_calibration_param_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_PLINE_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command assigns AE PLine data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _PLineTable_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_GET_PLINE_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command get current AE PLine data and packaged
// as struct _CmdParamPackage_t
// The output is the struct struct _PLineTable_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_SCENE_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetSceneMode_t {
	enum _SceneMode_t mode;
};
// @Description: This command changes scene mode value when AE is auto mode.
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AE_SET_SCENARIO_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAeSetScenarioMode_t {
	enum _ScenarioMode_t mode;
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//@page CMD_ID_AE_SET_FRAME_DURATION
//@verbatim
//CmdId: CMD_ID_AE_SET_FRAME_DURATION
//CmdChannel: StreamX
//RespChannel: StreamX
//ParameterType: Direct
//Parameter: CmdAeSetFrameDuration_t
//Description: This command changes the sensor frame duration time when AE is
//manual mode. The setting is a microsecond value.
//Type: Dynamic
//ResponsePayload: None.
//ResponseTime: Processed
//@endverbatim
//@struct  CmdAeSetFrameDuration_t
//Parameter of CMD_ID_AE_SET_FRAME_DURATION
struct _CmdAeSetFrameDuration_t {
	unsigned int frameDuration; //<frame duration, a microsecond value
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @page CMD_ID_AE_SET_TOUCH_TARGET
// @verbatim
// CmdId: CMD_ID_AE_SET_TOUCH_TARGET
// CmdChannel: StreamX
// RespChannel: StreamX
// ParameterType: Direct
// Parameter: CmdAeSetTouchTarget_t
// Description: This command changes the target of AE touch ROI.
// Type: Dynamic
// ResponsePayload: None.
// ResponseTime: Processed
// @endverbatim
// @struct  _CmdAeSetTouchTarget_t
// Parameter of CMD_ID_AE_SET_TOUCH_TARGET
struct _CmdAeSetTouchTarget_t {
	unsigned int touchTarget;
};


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @page CMD_ID_AE_SET_TOUCH_TARGET_WEIGHT
// @verbatim
// CmdId: CMD_ID_AE_SET_TOUCH_TARGET_WEIGHT
// CmdChannel: StreamX
// RespChannel: StreamX
// ParameterType: Direct
// Parameter: _CmdAeSetTouchWeight_t
// Description: This command changes the weight of AE touch ROI.
// Type: Dynamic
// ResponsePayload: None.
// ResponseTime: Processed
// @endverbatim
// @struct  _CmdAeSetTouchWeight_t
// Parameter of CMD_ID_AE_SET_TOUCH_TARGET_WEIGHT
struct _CmdAeSetTouchTargetWeight_t {
	int touchTargetWeight;
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @page CMD_ID_AE_SET_APPLY_MODE
// @verbatim
// CmdId: CMD_ID_AE_SET_APPLY_MODE
// CmdChannel: StreamX
// RespChannel: StreamX
// ParameterType: Direct
// Parameter: CmdAeSetMode_t
// Description: This command change the AE run mode for the stream.
//		The default mode is AE_APPLY_MODE_ASYNC.
//		Host can send this command before stream start to change the
//		current ae apply mode after the firmware is boot up.
// Type: Dynamic
// ResponsePayload: None.
// ResponseTime: Processed
// @endverbatim
// @struct  AeApplyMode_t
// Parameter of CMD_ID_AE_SET_APPLY_MODE
struct _CmdAeSetApplyMode_t {
	enum _AeApplyMode_t mode;
};

//AWB Command
//-----------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbSetMode_t {
	enum _AwbMode_t mode;
};
// @Description: This command changes the AWB run mode for the stream.
//               The default mode is AWB_MODE_AUTO.
//             Host can send this command at any time after the firmware
//               is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command is used to get the curreht awb algorithm
//               status.
//               The result will be written to the buffer specified in the
//               CmdAwbGetStatus_t and packaged as struct _CmdParamPackage_t.
//               Host can send this command at any time after the firmware
//               is boot up.
struct _AwbStatus_t {
	enum _AwbMode_t mode;
	enum _AwbLockState_t lockState;
	enum _AwbSearchState_t searchState;
	enum _AwbLightSource_t lightSource;
	unsigned int colorTemperature;
	struct _WbGain_t wbGain;
	struct _CcMatrix_t ccMatrix;
};
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_LOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbLock_t {
	enum _LockType_t lockType;
};
// @Description: This command is used to do lock operation on the AWB
//               algorithm.
//             The LOCK_TYPE_IMMEDIATELY will lock the AWB algorithm
//               immediately, no matter what the AWB status
//             now.
//             The LOCK_TYPE_CONVERGENCE will lock the AWB algorithm
//               after the ae settled.
//             Host can send this command at any time after the firmware
//               is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_UNLOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command  is used to unlock the AWB algorithm which is
//               locked by the previous lock
//             command.
//             Host can send this command at any time after the firmware is
//               boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_WB_GAIN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbSetWbGain_t {
	struct _WbGain_t wbGain;
};
// @Description: This command changes the current wb gain in manual mode.
//               Host can send this command at any time to apply a new wb gain
//               setting when the wb mode is manual.
//               And host can send this command in auto mode when the stream is
//               not started to set the initial wb gain.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_GET_WB_GAIN
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: struct _WbGain_t
// @Description: This command gets the current wb gain used. It is used for
//               debug.
//               Host can send this command at any time after the firmware is
//               boot up.
// @Type: Dynamic
// @ResponsePayload: struct _WbGain_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_CC_MATRIX
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbSetCcMatrix_t {
	struct _CcMatrix_t ccMatrix;
};
// @Description: This command changes the current cc coefficients matrix in
//               manual mode. Host can send this command
//             at any time to apply a new cc matrix setting when the wb mode
//               is manual. And can send this command in
//             auto mode when the stream is not started to set the initial
//               cc matrix.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_GET_CC_MATRIX
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: struct _CcMatrix_t
// @Description: This command gets the current cc matrix used in awb loop.
//               Host can send this command at any
//             time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: struct _CcMatrix_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_LIGHT_SOURCE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbSetLightSource_t {
	enum _AwbLightSource_t lightSource;
};
// @Description: This command change the reference light source for
//               AWB algorithm.
//               The light sources are predefined in AwbLightSource_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_COLOR_TEMPERATURE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAwbSetColorTemperature_t {
	//In K. For example, 1000 means 1000K, 5500 means 5500K
	unsigned int colorTemperature;
};
// @Description: This command changes the reference color temperature for
//               AWB algrithm.
//               And the behavior in manual mode is not determined yet.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command assigns AWB tuning data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _AwbTuningData_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_GET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command get current AWB tuning data and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _AwbTuningData_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_SET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command assigns AWB calibration data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _AwbCalibData_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AWB_GET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: packaged as struct _CmdParamPackage_t
// @Description: This command get current AWB calibration data and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _AwbCalibData_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//AF Command
//----------



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetMode_t {
	enum _AfMode_t mode;
};
// @Description: This command set the AF run mode for the stream. The default
//               mode is AF_MODE_MANUAL. Host can send
//              this command at any time to change the current af mode after
//               the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_LENS_RANGE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetLensRange_t {
	struct _LensRange_t lensRange;
};
// @Description: This command changes the lens position range. It is mainly
//               used for host to implement different
//             lens range in different scenario like macro, full range, etc.
//               Host can send this command at any time after the
//             firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_LENS_POS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetLensPos_t {
	unsigned int lensPos;
};
// @Description: This command change the lens position. In manual mode,
//               firmware will not change the lens
//              position. In CONTINUOUS_PICTURE or CONTINUOUS_VIDEO mode,
//               and it is not paused by the command
//              CMD_ID_AF_CANCEL, the auto algorithm may overwrite the lens
//               position.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_REGION
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command changes the AF measurement region of the
//               corresponding stream.
//               The input is the struct AaaRegion_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_TRIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command trigs a new focus searching. If the current mode
//               is ONE_SHOT, the algorithm
//             only search one time until convergence or failed. If the current
//               mode is CONTINUOUS_PICTURE or
//             CONTINUOUS_VIDEO, the algorithm will do a search until
//               convergence or failed and still keep in tracking. If
//        the current mode is CONTINUOUS_PICTURE or CONTINUOUS_VIDEO and
//               was paused by the last
//             command CMD_ID_AF_CANCEL, the CMD_ID_AF_TRIG command will
//               resume the tracking.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++






//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_CANCEL
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command cancels the one shot searching if it is still
//               in searching or pause the tracking if it
//             is in CONTINUOUS_PICTURE or CONTINUOUS_VIDEO mode. Host can
//               send CMD_ID_AF_TRIG to
//          resume the tracking for CONTINUOUS_PICTURE or CONTINUOUS_VIDEO
//               mode, or start a new searching
//             for ONE_SHOT mode. Host can send this command at any time after
//               the stream is started.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++





//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_LOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfLock_t {
	enum _LockType_t lockType;
};
// @Description: This command is used to do lock operation on the AF algorithm.
//             The LOCK_TYPE_IMMEDIATELY will lock the AF algorithm immediately,
//               no matter what the AE status now.
//             The LOCK_TYPE_CONVERGENCE will lock the AF algorithm after the
//               ae settled.
//             The AF is locked after this command is finished. Host can't
//               send any AF command except the UNLOCK
//             command after sending this command.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_UNLOCK
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to unlock the AF algorithm which is
//               locked by the previous lock
//              command. Host can send this command at any time the firmware
//               is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++





//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_FOCUS_ASSIST_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetFocusAssistMode_t {
	enum _FocusAssistMode_t mode;
};
// @Description: This command is used to set the flash focus assist mode. By
//               default it is off. In FOCUS_ASSIST_MODE_OFF
//             mode, the flash for focus assist is always disabled.
//               In FOCUS_ASSIST_MODE_ON mode, the flash for focus
//             assist is always on when a CMD_ID_AF_TRIG is send to focus
//               search or the algorithm need to do a focus
//             search in auto mode. In FOCUS_ASSIST_MODE_AUTO, the auto
//               focus algorithm will automatically determince
//             whether to turn on or off the flash light to assist focus
//               according to the current l-uminance.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_FOCUS_ASSIST_POWER_LEVEL
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetFocusAssistPowerLevel_t {
	unsigned int powerLevel;
};
// @Description: This command is used to set the flash power level for the
//               focus assist. The powerLevel should
//              be in the range of 0~100. 100 means 100 percent of the flash
//               power level. The default power level for focus is
//              20 percent.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current af algorithm status.
struct _AfStatus_t {
	enum _AfMode_t mode;
	struct _LensRange_t lensRange;
	unsigned int lensPos;
	struct _AaaRegion_t region;
	enum _AfLockState_t lockState;
	enum _AfSearchState_t searchState;
	enum _AfSearchRangeMode_t searchRangeMode;
	enum _AfCalibrationType_t calibType;
};
// @Type: Dynamic
// @ResponsePayload: BufCheckSum_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AF_SET_SEARCH_RANGE_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdAfSetSearchRangeMode_t {
	enum _AfSearchRangeMode_t mode;
};
// @Description: This command set the AF search range mode for the stream.
// The default mode is AF_SEARCH_RANGE_MODE_FULL.
// Host can send this command at any time to change the
// current af search mode after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++




////DYNAMIC_IQ Command
////-------------
//
////+++++++++++++++++++++++++++++++++++++++++++++++++
//// @CmdId: CMD_ID_LSC_GET_STATUS
//// @CmdChannel: StreamX
//// @RespChannel: StreamX
//// @ParameterType: Direct
//// @Parameter:
//struct _CmdDynamicIQPayload_t
//{
//    unsigned int bufAddrLo;
//    unsigned int bufAddrHi;
//    unsigned int bufSize;
//};


//CPROC Command
//-------------


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enables the cproc module. The default status is
//               enabled. Host can send this
//              command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disables the cproc module. The default status is
//               enabled. Host can send this
//             command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_SET_CONTRAST
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCprocSetContrast_t {
	unsigned int contrast;
};

// @Description: This command set the current stream's contrast. Host can
//               send this command at any time afer
//             the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_SET_BRIGHTNESS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCprocSetBrightness_t {
	unsigned int brightness;
};

// @Description: This command set the current stream's brightness. Host can
//               send this command at any time
//             after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_SET_SATURATION
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCprocSetSaturation_t {
	unsigned int saturation;
};

// @Description: This command set the current stream's saturation. Host can
//               send this command at any time
//             after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_SET_HUE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCprocSetHue_t {
	unsigned int hue;
};

// @Description: This command set the current stream's hue. Host can send this
//               command at any time after the
//             firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CPROC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to get the current cproc's setting.
// @Type: Dynamic
// @ResponsePayload: struct _CprocStatus_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//Miscellaneous Debug Command
//---------------------------


//BLS Command
//-----------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_BLS_SET_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdBlsSetMode_t {
	enum _BlsMode_t mode;
};
// @Description: This command set the bls modefor the stream. Host can send this
//              command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_BLS_SET_WINDOW
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdBlsSetWindow_t {
	enum _BlsWindType_t windType;
	struct _Window_t wind1;
	//Config wind2 when windType is BLS_WIND_TYPE_TWO_WIND
	struct _Window_t wind2;
};
// @Description: This command set the bls window while bls mode is dynamic mode.
//               Host can send this
//              command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_BLS_SET_BLACK_LEVEL
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
struct _CmdBlsSetBlackLevel_t {
	struct _PreBlackLevel_t bl;
};
// @Description: This command set the fixed black level value for the stream.
//               It is used for debug while bls mode is static mode.
//               Host can send this
//              command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_BLS_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command gets the black level setting of the specified
//               stream. The result will be returned in
//              the response payload as a struct of BlsStatus_t. Host can send
//               this command at any time after the
//              firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: BlsStatus_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//DEGAMMA Command
//---------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEGAMMA_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the degamma unit. Host can send this
//               command at any time after the
//              firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEGAMMA_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the degamma unit. Host can send this
//               command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEGAMMA_SET_CURVE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdDegammaSetCurve_t {
	struct _DegammaCurve_t curve;
};
// @Description: This command change the degamma curve setting for the stream.
//               The default degamma
//               curve is get from the calibration data. Host can send this
//               command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEGAMMA_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command get the degamma status. The bufAddLo and
//               bufAddrHi specified the address
//               of a struct DegammaStatus_t and the bufSize should equal to
//               DegammaStatus_t. Firmware will fill the
//               status data to this buf and send the RESP_ID_CMD_DONE
//               response. Host can send this command at any time
//               after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: BufCheckSum_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//CorePipe Cmd
//DPC Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DPC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the DPC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DPC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the DPC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DPC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdDpcConfig_t {
	struct _DynamicDPCParams_t dpcParams;
};
// @Description: This command changes the DPC setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DPC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current DPC setting.
// @Type: Dynamic
// @ResponsePayload: DynamicDPCParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//SNR Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SNR_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the SNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SNR_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the SNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SNR_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdSnrConfig_t {
	struct _SinterParams_t sinterParams;
};
// @Description: This command changes the SNR setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SNR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current SNR setting.
// @Type: Dynamic
// @ResponsePayload: struct _SinterParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//TNR Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TNR_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
enum _CmdTemperMode_t {
	CMD_TEMPER_MODE_INVALID = -1,
	CMD_TEMPER_MODE_3,
	CMD_TEMPER_MODE_2,
	CMD_TEMPER_MODE_TDB,	//Temper mode is according to tdb
	CMD_TEMPER_MODE_MAX
};

struct _CmdTnrEnable_t {
	int isUsingTdbEn;	//is the enable according to tdb
	int isFullStill;		//indicate the TNR is for full still
	enum _CmdTemperMode_t mode;
	unsigned char refNum;			//reference num for TNR
};

// @Description: This command enable the TNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TNR_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdTnrDisable_t {
	int isFullStill; //indicate the TNR is for full still
};

// @Description: This command disable the TNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TNR_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdTnrConfig_t {
	struct _TemperParams_t temperParams;
};
// @Description: This command changes the TNR setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TNR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current SNR setting.
// @Type: Dynamic
// @ResponsePayload: struct _TemperParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//CAC Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the CAC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the CAC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdCacConfig_t {
	struct _CaCorrectionParams_t cacParams;
};
// @Description: This command changes the CAC setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CAC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current CAC setting.
// @Type: Dynamic
// @ResponsePayload: CaCorrectionParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//RLSC Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_RLSC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the RLSC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_RLSC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the RLSC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_RLSC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdRlscConfig_t {
	struct _RadialShadingParams_t radialShadingParams;
};
// @Description: This command changes the RLSC setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_RLSC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current RLSC setting.
// @Type: Dynamic
// @ResponsePayload: RadialShadingParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//MLSC Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_MLSC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the MLSC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_MLSC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the MLSC function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_MLSC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdMlscConfig_t {
	struct _MeshShadingParams_t meshShadingParams;
};
// @Description: This command changes the MLSC setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_MLSC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current MLSC setting.
// @Type: Dynamic
// @ResponsePayload: RadialShadingParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//IRIDIX Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the IRIDIX function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the IRIDIX function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_SET_MODE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdIridixSetMode_t {
	enum _IridixMode_t mode;
};
// @Description: This command changes the IRIDIX mode for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_SET_CTRL_INFO
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command assigns Iridix control and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct IridixCtrlInfo_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current IRIDIX status
//               and packaged as struct _CmdParamPackage_t
//               The input is the struct IridixStatus_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_SET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command assigns Iridix tuning data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _IridixTuningData_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_GET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command get current Iridix tuning data and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _IridixTuningData_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_SET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command assigns Iridix calibration data and packaged
//               as struct _CmdParamPackage_t
//               The input is the struct struct _IridixCalibData_t
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IRIDIX_GET_CALIB_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: Packaged as struct _CmdParamPackage_t
// @Description: This command get current Iridix calibration data  and packaged
//               as struct _CmdParamPackage_t
//               The output is the struct struct _IridixCalibData_t
// @Type: Dynamic
// @ResponsePayload: struct _CmdParamPackage_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//DEMOSAIC Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEMOSAIC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdDemosaicConfig_t {
	struct _DemosaicParams_t demosaicParams;
};
// @Description: This command changes the DEMOSAIC setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DEMOSAIC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current DEMOSAIC setting.
// @Type: Dynamic
// @ResponsePayload: DemosaicParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//PF Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PF_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdPfConfig_t {
	struct _PfParams_t pfParams;
};
// @Description: This command changes the PF setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PF_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current PF setting.
// @Type: Dynamic
// @ResponsePayload: PfParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//CNR Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CNR_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the CNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CNR_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the CNR function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CNR_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdCnrConfig_t {
	struct _CnrParams_t cnrParams;
};
// @Description: This command changes the CNR setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CNR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current CNR setting.
// @Type: Dynamic
// @ResponsePayload: CnrParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//GAMMA Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GAMMA_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the GAMMA function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GAMMA_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the GAMMA function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GAMMA_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdGammaConfig_t {
	struct _RgbGammaParams_t rgbGammaParams;
};
// @Description: This command changes the GAMMA setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GAMMA_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current GAMMA setting.
// @Type: Dynamic
// @ResponsePayload: RgbGammaParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
//TODO:
// @CmdId: CMD_ID_GAMMA_SET_GAMMA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: TODO
// @Description: The CMD is to be implement.This command is used to set
//		the GAMMA.The required range must be 1 through 500.
//		The default value is typically 220 (gamma = 2.2).
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++


//CS Command
//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CS_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the CS function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CS_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the CS function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CS_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdCsConfig_t {
	struct _RgbCsConvParams_t rgbCsConvParams;
};
// @Description: This command changes the CS setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CS_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current CS setting.
// @Type: Dynamic
// @ResponsePayload: RgbCsConvParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//FR_SHARPEN Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_FR_SHARPEN_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the FR_SHARPEN function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_FR_SHARPEN_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the FR_SHARPEN function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_FR_SHARPEN_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdFrSharpenConfig_t {
	struct _SharpenFrParams_t sharpenFrParams;
};
// @Description: This command changes the FR_SHARPEN setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_FR_SHARPEN_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current FR_SHARPEN setting.
// @Type: Dynamic
// @ResponsePayload: RgbCsConvParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//GE Command
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GE_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the GE function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GE_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the GE function.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GE_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdGeConfig_t {
	struct _GreenEqualizationParams_t ge;
};
// @Description: This command changes the GE setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GE_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current GE setting.
// @Type: Dynamic
// @ResponsePayload: RgbCsConvParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//


//Frame CTRL Command
//---------------------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_FRAME_CTRL
// @CmdChannel: NonBlock
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdFrameCtrl_t {
	struct _FrameControl_t frameCtrl;
};
// @Description: This command sends a frame control command to firmware.
//               It gathers all the control information in one command.
//               It require that all the control param should be applied at one
//               frame and send result to host by Meta data every frame.
//               We only support full frame control now(for Android), firmware
//               will get whole pipe control information from host including:
//                   Sensor: expo info/lens position
//                   MIPI: Raw output
//            ISP:  Some HW module, such gamma, CAC,LSC,DPC,Sharpen,CROP,
//               all YUV output and so on.
//                   AE: AE lock/unlock, ROI region, FPS and so on.
//                   AWB:Light Source/Color Temperature and so on.
//                   AF:AF lock/unlock, ROI region and so on
//               Host should send this command after the firmware boots up.
//               Host should send at least two PFC cmds before start stream,
//               because for some sensor control param should be applied before
//               two frames in advance.
//               Host shouldn't send any cmd which onflicted this CMD, such as
//                  CMD_ID_SEND_BUFFER,
//                  CMD_ID_ENABLE_OUT_CH
//                  CMD_ID_CAPTURE_YUV
//                  CMD_ID_CAPTURE_RAW
//                  CMD_ID_SET_ZOOM_WINDOW
//                  CMD_ID_SEND_FRAME_INFO
//                  
//It means that any control included in struct _FrameControl_t, Host
//should send with PFC cmd with enabling related parameter.
//ResponsePayload: None
//ResponseTime: Enqueued
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_FRAME_INFO
// @CmdChannel: NonBlock
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdSendFrameInfo_t {
	struct _FrameInfo_t frameInfo;
};
// @Description: This command sends a post process frame info to firmware.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//BUFFER Command
//--------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_BUFFER
// @CmdChannel: NonBlock
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSendBuffer_t {
	enum _BufferType_t bufferType;
	struct _Buffer_t buffer;
};
// @Description: This command sends a free buffer for firmware to use.
//		--1. For BUFFER_TYPE_PREVIEW, BUFFER_TYPE_VIDEO,
//	BUFFER_TYPE_ZSL, the buf A, B, C are used
//		according to the current struct _ImageProp_t setting of
//	the corresponding channel.
//			Host can send this preview/video/zsl/rawzsl
//	buffer at any time after the firmware is boot up.
//			All the preview/video/zsl/rawzsl buffer will
//	be released by firmware after processing a
//			CMD_ID_STOP_STREAM command.
//			--2. For BUFFER_TYPE_RAW_ZSL and
//	BUFFER_TYPE_RAW_TEMP, only the buf A is used to capture the raw
//			frame in RGB Bayer mode. The bufA and bufB are
//	used for RGB-IR mode. The buf A is for RGB Bayer data,
//			and the buf B is for IR data.
//			--3. For BUFFER_TYPE_HDR_STATS_DATA, only the
//	buf A is used. The buf A size should be
//			enough to store the hdr stats data for one
//	frame. Host should send 3 buffers in order to enable HDR.
//			--4. For BUFFER_TYPE_META_INFO, it is used as
//	the storage buffer for response
//			RESP_ID_FRAME_DONE. Only the buf A is used and
//	the buffer size should be enough to store the struct _MetaInfo_t.
//			--5. For BUFFER_TYPE_FRAME_INFO, it is used as
//		the storage buffer for response
//			RESP_ID_FRAME_INFO. Only the buf A is used and
//	the buffer size should be enough to store the Mode3FrameInfo_t.
//			--6, For BUFFER_TYPE_TNR_REF, the TNR has mode3
//	and mode2, default in FW is mode3; mode3 need two reference
//				buffer; mode2 need one reference buf. two
//	reference buf should send by one cmd with A and B plane.
//			this cmd should send before enable TNR.
//			the reference buf size must follow below
//	function:
//			#define COMMON_BUFFER_ALIGN_SIZE (1 * 1024)
//				stride = AIDT_ALIGN_UP((width*20+7)/8,
//		COMMON_BUFFER_ALIGN_SIZE);
//			*size0 = stride * height;  for reference A
//			*size1 = stride * height;  for reference B
//		--7, For BUFFER_TYPE_TNR_FULL_STILL_REF, same
//		as BUFFER_TYPE_TNR_REF
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Enqueued
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_ZOOM_TMP_BUFFER
// @CmdChannel: NonBlock
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSendZoomTmpBuffer_t {
	unsigned int bufBaseLo;
	unsigned int bufBaseHi;
	unsigned int bufSize;
};
// @Description: This command sends a free buffer
//for firmware to use.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Enqueued
//++++++++++++++++++++++++++++++++++++++++++++++++++


//DITHERING Command
//--------------
//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_DITHERING_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDitheringEnable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command enable the dithering
//function. Host can send this command at any time
//after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++




//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_DITHERING_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDitheringDisable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command disable the dithering
//function. Host can send this command at any time
//after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++





//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_DITHERING_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDitheringGetStatus_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command get the dithering status.
//		Host can send this command at any time
//               after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: DitheringStatus_t
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++


//FCLIP Command
//--------------
//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_FCLIP_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdFclipEnable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command enable the fclip
//function. Host can send this command at
 //any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++




//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_FCLIP_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdFclipDisable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command disable the fclip
//function. Host can send this command at any
//time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++





//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_FCLIP_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdFclipGetStatus_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command get the fclip status.
//Host can send this command at any time
//after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: PostFclipByChannel_t
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++


//HFLIP Command
//--------------
//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_HFLIP_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdHflipEnable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command enable the hflip
//function. Host can send this command at any
//time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++




//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_HFLIP_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdHflipDisable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command disable the hflip
//function. Host can send this command at any
//time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++





//+++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_HFLIP_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdHflipGetStatus_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command get the hflip status.
//Host can send this command at any time
//after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: PostHflipByChannel_t
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++




/*YUVNR Command*/
//--------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_YUV_NR_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the YUVNR block.
//Host can send this command at any time after the
//              firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_YUV_NR_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the function
//in YUVNR block. Host can send this command at
//any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_YUV_NR_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdYuvNrConfig_t {
	struct _TdbYuvNr_t param;
};
// @Description: This command set the YUVNR module
//parameters for the stream.
// Host can send this command at any time after
//the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_YUV_NR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the
//current parameters in YUVNR block.
// @Type: Dynamic
// @ResponsePayload: TdbYuvNr_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//IE Command
//--------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IE_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the mode in
//image effect block. Host can send this command
//at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IE_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the function in
//image effect block. Host can send this command at
//any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IE_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:	IeStatus_t
struct _CmdIeConfig_t {
	struct _IeStatus_t param;
};
// @Description: This command set the IE
//mode and parameters for the stream.
// Host can send this command at any time
//after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_IE_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command is used to get the
// current IE mode and parameters
// in image effect block.
// @Type: Dynamic
// @ResponsePayload: IeStatus_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//SHARPEN Command
//--------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SHARPEN_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSharpenEnable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command enable the sharpen function.
//Host can send this command at any time after the
//firmware is boot up.
//Dynamic wdma assign case:For wdma0 has no
//sharpen HW, so the fourth enable output channel
//will has no shapren,
//and the CMD response "CMD_STATUS_SUCCESS"
//but take no effect.
//Static wdma assign case:For wdma0 has no
//sharpen HW, so the output channel using wdma0
//will has no shapren,
//and the CMD will resonse
//"RESP_ERROR_CODE_UNSUPPORTED_SHARPEN_ID".
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SHARPEN_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSharpenDisable_t {
	enum _CdbIspPipeOutCh_t id;
};
// @Description: This command disable the sharpen
//function. Host can send this command at any time
//after the firmware is boot up.
//Dynamic wdma assign case:For wdma0 has no
//sharpen HW, so the fourth enable output channel has
//no shapren, and the CMD response "CMD_STATUS_SUCCESS"
//but take no effect.
//Static wdma assign case:For wdma0 has no
//sharpen HW, so the output channel using wdma0 will
//has no shapren, and the CMD will resonse
//"RESP_ERROR_CODE_UNSUPPORTED_SHARPEN_ID".
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SHARPEN_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdSharpenConfig_t {
	enum _CdbIspPipeOutCh_t id;
	struct _TdbSharpRegByChannel_t SharpenConfig;
};
// @Description: This command changes the sharpening
//	params for the stream. The default params is
//	gotten from the calibration data. Host can send
//	this command at any time after the firmware is
//	boot up.
//Dynamic wdma assign case:For wdma0 has no
//sharpen HW, so the fourth enable output channel
//will has no shapren, and the CMD response
//"CMD_STATUS_SUCCESS" but take no effect. Static
//wdma assign case:For wdma0 has no sharpen
//HW, so the output channel using wdma0 will has no
//shapren, and the CMD will resonse
//"RESP_ERROR_CODE_UNSUPPORTED_SHARPEN_ID".
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SHARPEN_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command is used to get the
//	current sharpen setting in post block.
//	Dynamic wdma assign case:For wdma0 has no
//	sharpen HW, so the fourth
//	enable output channel will has no shapren,
//	and the CMD response "CMD_STATUS_SUCCESS"
//	but take no effect.
//	Static wdma assign case:For wdma0 has no
//	sharpen HW, so the output
//	channel using wdma0 will has no shapren,
//	and the CMD will resonse
// "RESP_ERROR_CODE_UNSUPPORTED_SHARPEN_ID".
// @Type: Dynamic
// @ResponsePayload: CmdSharpenGetStatus_t
struct _CmdSharpenGetStatus_t {
	enum _CdbIspPipeOutCh_t id;
	struct _TdbSharpRegByChannel_t SharpenConfig;
};
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// TODO:
// @CmdId: CMD_ID_SHARPEN_SET_SHARPNESS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: TODO
// @Description: The CMD is to be implement.This command is use to set
//               sharpness. The required range must be 0 through 100.
//				 The default value must be 50.Host can send this
//               command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//ZZHDR Command
//--------------
//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ZZHDR_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enable the zzhdr function. Host can send this
//               command at any time after the
//              firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ZZHDR_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disable the zzhdr function. Host can send this
//               command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ZZHDR_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the zzhdr setting for the stream.
//               The default tuning data
//               is gotten from the calibration data binary. Host can send
//               this command at any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdZzhdrConfig_t {
	struct _TdbZzhdr_t zzhdrConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_ZZHDR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current zzhdr setting in
//               pdzz block.
// @Type: Dynamic
// @ResponsePayload: TdbZzhdr_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the pdc setting for the stream.
//               The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdPdcConfig_t {
	struct _TdbPdc_t pdcConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current pdc setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDE_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the pde setting for the stream.
//               The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdPdeConfig_t {
	struct _TdbPde_t pdeConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDE_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current pde setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDNC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the pdnc setting for the stream.
//               The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdPdncConfig_t {
	struct _TdbPdnc_t pdncConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDNC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current pdnc setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDBPC_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the pdbpc setting for the stream.
//               The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdPdbpcConfig_t {
	struct _TdbBpc_t pdbpcConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDBPC_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current pdbpc setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDCIP_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command changes the pdcip setting for the stream.
//               The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

struct _CmdPdcipConfig_t {
	struct _TdbPdcip_t pdcipConfig;
};


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_PDCIP_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to get the current pdcip setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//HBIN Command
//-----------

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_HBIN_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None

// @Description: This command enable the hbin for the stream. For hbin is
//               corresponding to sensor prop. So, this command
//               must be send before starting a stream  and can't be changed
//               after the stream is started.
//
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_HBIN_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None

// @Description: This command disable the hbin for the stream. For hbin is
//               corresponding to sensor prop. So, this command
//               must be send before starting a stream  and can't be changed
//               after the stream is started.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_HBIN_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:
struct _CmdPreHbin_t {
	struct _TdbHbin_t hbinParams;
};
// @Description: This command set the hbin param for the stream. Host can send
//               this command at any time after the firmware is boot up.
//               But host mustn't change the enable status when stream
//				is on.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_HBIN_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:struct _CmdParamPackage_t
// @Description: This command gets  hbin param for the stream. The result will
//               be returned in the response payload as a struct of
//               PrepH2BinParams_t. Host can send this command at
//               any time after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: PrepH2BinParams_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_CONFIG_PARAM
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdDirConfigParam_t {
	struct _TdbDir_t param;
};
// @Description: This command changes the HW DIR
//	coefficients.
//               The default coefficients are in
//               HW registers. And we suppose the
//	coefficients
//               come from tuning data. But host
//               can override them at any time.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_BPC_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enables DIR BPC block.
//	Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_BPC_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disables DIR BPC block.
//	Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_DECON_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enables DIR DECON block.
//	Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_DECON_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disables DIR
//	DECON block. Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_CIP_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enables DIR CIP block.
//		Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_CIP_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disables DIR
// CIP block. Host can send
//               this command at any time
//	after the firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: InDirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command gets DIR status
// of the specified stream.
//               The result will be returned in
//              the response payload as a
// struct of DirStatus_t. Host
//               can send this command at
// any time after the
//              firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: DirStatus_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_RGB_ADJUST_ENABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command enables DIR RGB adjust.
// Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_RGB_ADJUST_DISABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter: None
// @Description: This command disables DIR RGB adjust.
// Host can send
//               this command at any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_DIR_IR_STREAM_SEL
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdDirIrStreamSel_t {
	int isDeconIr;   //true: decon ir;  false: original ir
};
// @Description: This command sel output ir type.
//              Host can send this command at
//               any time after the
//               firmware is boot up.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_RSZ_TABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdSetRszTable_t {
	enum _CdbIspPipeOutCh_t id;
	struct _YuvResizeTable_t yuvResizeTable;
};
// @Description: This command changes the RSZ_TABLE
//		setting for the stream. The default filter
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_GET_RSZ_TABLE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter:CmdParamPackage_t
// @Description: This command is used to get
// the current RSZ_TABLE setting.
// @Type: Dynamic
// @ResponsePayload: CmdGetRszTable_t
struct _CmdGetRszTable_t {
	//id
	enum _CdbIspPipeOutCh_t id;
	struct _YuvResizeTable_t yuvResizeTable;
};
// @Description: This command is used to get the
// current RSZ_TABLE setting.

// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_M2M_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
struct _CmdM2MConfig_t {
	struct _M2MTdb_t m2mParams;
};
// @Description: This command changes the M2M
// setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_M2M_GET_STATUS
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _CmdParamPackage_t
// @Description: This command is used to
// get the current M2M setting.
// @Type: Dynamic
// @ResponsePayload: Status_t
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SET_CVIP_BUF_LAYOUT
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdSetCvipBufLayout_t {
	enum _SensorId_t   sensorId;
	enum _CvipBufType_t cvipBufType;
	unsigned int bufAddrLo;  //Low 32bit address of cvip buf layout
	unsigned int bufAddrHi;  //High 32bit address of cvip buf layout
	unsigned int bufSize;    //buf size
};
// @Description: This command is used to send buffer(including
//               embedded pre data //buf,
//					embedded post data buf
//               and stat buf) layout.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_CONFIG_CVIP_SENSOR
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdConfigCvipSensor_t {
	enum _SensorId_t sensorId;
	struct _ConfigCvipSensorParam_t param;
};
// @Description: This command is used to send
// Cvip sensor config info.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_START_CVIP_SENSOR
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdStartCvipSensor_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to turn on Cvip sensor.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_STOP_CVIP_SENSOR
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdStopCvipSensor_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to turn off Cvip sensor.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_STANDBY_CVIP_SENSOR
// @CmdChannel: NonBlock
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _CmdStandbyCvipSensor_t {
	enum _SensorId_t sensorId;
};
// @Description: This command is used to standby
// Cvip sensor for saving power.
// @Type: Static
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++

// @CmdId: CMD_ID_CRISP_DETECTION_CFG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdCrispCfgDetection_t {
	enum _CdbIspPipeOutCh_t chId;
	int enableFD;
	int enableSTD;
	int enableSD;
};
// @CmdId: CMD_ID_LSC_SET_STRENGTH
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command changes the LSC STRENGTH setting
// for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_SET_CCT_THRESHOLD
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command changes the LSC CCT_THRESHOLD setting
// for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_SET_SMOOTH_RATIO
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command changes the LSC SMOOTH_RATIO setting
// for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_SET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command changes the LSC TuningData setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_GET_TUNING_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command is used to get the current LSC TuningData setting.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_SET_CALIBRATION_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command changes the LSC CalibData setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_LSC_GET_CALIBRATION_DATA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command is used to get the current LSC CalibData setting.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_AUTOCONTRAST_CONFIG
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
struct _CmdAutoContrastConfig_t {
	struct _AutoContrast_t autoContrastParams;
};
// @Description: This command changes the auto contrast setting for
// the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
struct _Cmd3DLutConfig_t {
	struct _Lut3D_t lut3DParams;
};
// @Description: This command changes the 3D-Lut setting for the stream.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#ifdef SCENE_MODE_IMPLEMENT // This define will be removed latter
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TDB_SET_PIPELINE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
struct _CmdTdbSetPipeLine_t {
	struct _SceneModePipeDelta_t		  sceneModePipe;
	struct _PipeMappingDelta_t      pipeMappingDelta[SCENARIO_MODE_MAX];
};
// @Description: This command changes the pipeLine config and mapping
// table of scene mode
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TDB_GET_PIPELINE
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command get the pipeLine config and mapping table
// of scene mode
// @Type: Dynamic
// @ResponsePayload: _CmdTdbGetPipeLine_t
struct _CmdTdbGetPipeLine_t {
	struct _SceneModePipeDelta_t sceneModePipe;
	struct _PipeMappingDelta_t      pipeMappingDelta[SCENARIO_MODE_MAX];
};
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TDB_SET_AAA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
struct _CmdTdbSetAaa_t {
	struct _AeCdb_t           aeCdb;
	struct _PLineTable_t
		plineCdb[SCENE_PREFERENCE_TUNING_AAA_SETS_NUM];
	struct _AwbCdb_t	awbCdb;
	struct _AfCdb_t	afCdb;
	struct _IridixCdb_t	iridixCdb;
	struct _Lut3D_t	lut3D;
	struct _AutoContrast_t	autoContrast;
	struct _LscCdb_t	lscCdb;
	struct _MappingAaa_t	mappingAaa[SCENARIO_MODE_MAX];
};
// @Description: This command changes the 3A config and mapping table
// of scene mode
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_TDB_GET_AAA
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: CmdParamPackage_t
// @Description: This command get the 3A config and mapping table of
// scene mode
// @Type: Dynamic
// @ResponsePayload: _CmdTdbGetAaa_t
struct _CmdTdbGetAaa_t {
	struct _AeCdb_t	aeCdb;
	struct _PLineTable_t
		plineCdb[SCENE_PREFERENCE_TUNING_AAA_SETS_NUM];
	struct _AwbCdb_t	awbCdb;
	struct _AfCdb_t	afCdb;
	struct _IridixCdb_t	iridixCdb;
	struct _Lut3D_t	lut3D;
	struct _AutoContrast_t	autoContrast;
	struct _LscCdb_t	lscCdb;
	struct _MappingAaa_t	mappingAaa[SCENARIO_MODE_MAX];
};
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#endif
// @Description: This command is used to enable/disable the detection
//functions of CRISP post process.
// @Type: Dynamic
// @ResponsePayload: None
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


/* ---------------------------------------------------------------- */
/*                                   Response Param List                  */
/* ---------------------------------------------------------------- */


/*
 * Each response is detailed in the following columns:
 *
 * RESP_ID_XXX:   The id fo the corresponding response.
 *
 * RespChannel:   Specify which response channel  this kind response will send.
//               "Global" means it will send in the global
 *                response channel. StreamX means it will send in the stream
//               response channel. The X specify which stream
 *                response channel it will send. It can be 1, 2 or 3, depend
//               on which stream this response is for. Some
 *                response can both send in global channel and stream channel.
//               It will be specified as Global+StreamX.
 *
 * ParameterType: Describe how the response parameter is included. "Direct"
//               means the response parameter is stored
//    in the respParam field in the struct _Resp_t structure. "Indirect"
//               means the response parameter is in another buffer.
 *                The buffer address, size and checksum is specified in a
//               struct of struct _RespParamPackage_t. The
 *                RmdParamPackage will be stored in the respParam field in
//               the struct _Resp_t structure.
 *
 * Parameter:     The response parameter definition for the specified
//               response.
 *
 * Description:   A detail description for the specified response
 */


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_CMD_DONE
// @RespChannel: Global+StreamX
// @ParameterType: Direct
// @Parameter:
struct _RespCmdDone_t {
	unsigned int cmdSeqNum;
	//The host2fw command seqNum. To indicate which
	//command this response refer to.
	unsigned int cmdId;
	//The host2fw command id for host double check.
	unsigned short cmdStatus;
	//Indicate the command process status. 0 means
//               success. 1 means fail. 2 means skipped
	unsigned short errorCode;
	//If the cmdStatus is 1, that means the command
	//is processed fail, host can check the errorCode
	//to get the detail error
//               information
	unsigned char  payload[36];
	//The response payload will be in different struct
	//type accroding to different cmd done
	//response. See the detailed
	//command for reference.
};
// @Description: This response is used for response to each host command.
//               Each host command will get this
//             kind response after firmware has finished the command. For
//               "Frame CTRL Command" and
//             "Buffer Command", firmware will send the RESP_ID_CMD_DONE
//               response after these commands are
//             accepted. For other commands, the RESP_ID_CMD_DONE will
//               send when it has been processed.
// @CmdStatus:
#define CMD_STATUS_SUCCESS (0)
#define CMD_STATUS_FAIL    (1)
#define CMD_STATUS_SKIPPED (2)
// @ErrorCode:
#define RESP_ERROR_CODE_NO_ERROR                        (0)
#define RESP_ERROR_CODE_CALIB_NOT_SETUP                 (1)
#define RESP_ERROR_CODE_SENSOR_PROP_NOT_SETUP           (2)
#define RESP_ERROR_CODE_UNSUPPORTED_SENSOR_INTF         (3)
#define RESP_ERROR_CODE_SENSOR_RESOLUTION_INVALID       (4)
#define RESP_ERROR_CODE_UNSUPPORTED_STREAM_MODE         (5)
#define RESP_ERROR_CODE_UNSUPPORTED_SENSOR_ID           (6)
#define RESP_ERROR_CODE_ASPECT_RATIO_WINDOW_INVALID     (7)
#define RESP_ERROR_CODE_UNSUPPORTED_IMAGE_FORMAT        (8)
#define RESP_ERROR_CODE_OUT_RESOLUTION_OUT_OF_RANGE     (9)
#define RESP_ERROR_CODE_LOG_WRONG_PARAMETER             (10)
#define RESP_ERROR_CODE_INVALID_BUFFER_SIZE             (11)
#define RESP_ERROR_CODE_INVALID_AWB_STATE               (12)
#define RESP_ERROR_CODE_INVALID_AF_STATE                (13)
#define RESP_ERROR_CODE_INVALID_AE_STATE                (14)
#define RESP_ERROR_CODE_UNSUPPORTED_CMD                 (15)
#define RESP_ERROR_CODE_QUEUE_OVERFLOW                  (16)
#define RESP_ERROR_CODE_SENSOR_ID_OUT_OF_RANGE          (17)
#define RESP_ERROR_CODE_CHECK_SUM_ERROR                 (18)
#define RESP_ERROR_CODE_BUFFER_SIZE_ERROR               (19)
#define RESP_ERROR_CODE_UNSUPPORTED_BUFFER_TYPE         (20)
#define RESP_ERROR_CODE_UNSUPPORTED_COMMAND_ID          (21)
#define RESP_ERROR_CODE_STREAM_ID_OUT_OF_RANGE          (22)
#define RESP_ERROR_CODE_INVALID_STREAM_STATE            (23)
#define RESP_ERROR_CODE_INVALID_STREAM_PARAM            (24)
#define RESP_ERROR_CODE_UNSUPPORTED_MULTI_STREAM_MODE1  (25)
#define RESP_ERROR_CODE_UNSUPPORTED_LOG_DEBUG           (26)
#define RESP_ERROR_CODE_PACKAGE_SIZE_ERROR              (27)
#define RESP_ERROR_CODE_PACKAGE_CHECK_SUM_ERROR         (28)
#define RESP_ERROR_CODE_INVALID_PARAM                   (29)
#define RESP_ERROR_CODE_TIME_OUT                        (30)
#define RESP_ERROR_CODE_CANCEL                          (31)
#define RESP_ERROR_CODE_REPEAT_TNR_REF_BUF              (32)
#define RESP_ERROR_CODE_ZOOM_WIINDOW_ALIGN_ERROR        (33)
#define RESP_ERROR_CODE_ZOOM_WIINDOW_SIZE_ERROR         (34)
#define RESP_ERROR_CODE_HARDWARE_ERROR                  (35)
#define RESP_ERROR_CODE_MEMORY_LACK                     (36)
#define RESP_ERROR_CODE_TNR_REF_BUF_INVALID             (37)
#define RESP_ERROR_CODE_INVALID_DYNAMIC_IQ_STATE        (38)
#define RESP_ERROR_CODE_INVALID_LSC_STATE               (39)
#define RESP_ERROR_CODE_UNSUPPORTED_SHARPEN_ID          (40)

//TODO: Add more error code here
//++++++++++++++++++++++++++++++++++++++++++++++++++






//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_FRAME_DONE
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _MetaInfo_t
// @Description: This response is used for return a group of filled frame
//               buffer to host. The buffer returned in this
//             response is captured from the same sensor input frame. The
//               indirect buffer is from the MetaInfo buffer queue.
//++++++++++++++++++++++++++++++++++++++++++++++++++





//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_FRAME_INFO
// @RespChannel: StreamX
// @ParameterType: Indirect
// @Parameter: struct _FrameInfo_t
// @Description: This response is used to return a Mode3FrameInfo_t to host
//               for STREAM_MODE_3. The indirect buffer is from the
//               FrameInfo buffer queue.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_ERROR
// @RespChannel: Global+StreamX
// @ParameterType: Direct
// @Parameter:
struct _RespError_t {
	enum _ErrorLevel_t errorLevel;
	struct _ErrorCode_t  errorCode;
};
// @Description: This response is used for firmware to tell host that some
//               error happened inside firmware.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_GROUP_HOLD
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorGroupHold_t {
	enum _SensorId_t sensorId;
};
// @Description: This response is used for firmware to tell host to hold the
//               group register of the sensor.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_GROUP_RELEASE
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorGroupRelease_t {
	enum _SensorId_t sensorId;
};
// @Description: This response is used for firmware to tell host to release
//               the group register of the sensor.
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_AGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetAGain_t {
	enum _SensorId_t sensorId;
	unsigned int aGainSetting;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               analog gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_DGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetDGain_t {
	enum _SensorId_t sensorId;
	unsigned int dGain;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               digital gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_ITIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetItime_t {
	enum _SensorId_t sensorId;
	unsigned int iTimeSetting; ///< itime register setting
	unsigned int DurationSetting; ///< duration register setting
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               itime. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_HIGH_ITIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrHighItime_t {
	enum _SensorId_t sensorId;
	unsigned int iTimeSetting;
	unsigned int DurationSetting;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr high itime. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_ITIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime; //In microsecond.
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low itime. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_ITIME_RATIO
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowItimeRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low itime ratio. It is for
//             debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_EQUAL_ITIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrEqualItime_t {
	enum _SensorId_t sensorId;
	unsigned int itime;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr time when the itime type
//             is equal for high and low itime.
//++++++++++++++++++++++++++++++++++++++++++++++++++






//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_HIGH_AGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrHighAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr high analog gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_AGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low analog gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_AGAIN_RATIO
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowAGainRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low analog gain ratio. It is for
//             debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_EQUAL_AGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrEqualAGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr time when the analog gain type
//             is equal for high and low analog gain.
//++++++++++++++++++++++++++++++++++++++++++++++++++






//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_HIGH_DGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrHighDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr high digital gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_DGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low digital gain. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_LOW_DGAIN_RATIO
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrLowDGainRatio_t {
	enum _SensorId_t sensorId;
	unsigned int ratio;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr low digital gain ratio. It is for
//             debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_SENSOR_SET_HDR_EQUAL_DGAIN
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespSensorSetHdrEqualDGain_t {
	enum _SensorId_t sensorId;
	unsigned int gain; //Multiplied by 1000
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               hdr time when the digital gain type
//             is equal for high and low digital gain.
//++++++++++++++++++++++++++++++++++++++++++++++++++





//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_LENS_SET_POS
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespLensSetPos_t {
	enum _SensorId_t sensorId;
	unsigned int lensPos;
};
// @Description: This response is used for firmware to tell host to CTRL sensor
//               lens position. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_FLASH_SET_POWER
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespFlashSetPower_t {
	enum _SensorId_t sensorId;
	unsigned int powerLevel;
};
// @Description: This response is used for firmware to tell host to set the
//               power level of the flash light. It is
//             for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_FLASH_SET_ON
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespFlashSetOn_t {
	enum _SensorId_t sensorId;
	unsigned int time; //In microsecond
};
// @Description: This response is used for firmware to tell host to set the
//               flash light on with the time It is
//             for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++




//++++++++++++++++++++++++++++++++++++++++++++++++++
// @RespId: RESP_ID_FLASH_SET_OFF
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespFlashSetOff_t {
	enum _SensorId_t sensorId;
};
// @Description: This response is used for firmware to tell host to set the
//               flash light off. It is for debug.
//++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++

// @RespId: RESP_ID_IMC_CAM_RESET_REQ
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespCamRst_t {
	enum _SensorId_t sensorId;
};
// @Description: This response is used for firmware to notify host that ISP
//FW received a camera reset request from CVIP
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++

// @RespId: RESP_ID_IMC_CAM_RESET_RECOVERY
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: RespCamRst_t;
// @Description: This response is used for firmware to notify host that camera
//reset request from CVP has already accomplished.
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++

// @RespId: RESP_ID_IMC_WAIT_CVIP_ACK_OVERTIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter:
struct _RespImcWaitCvipAckOverTime_t {
	enum _SensorId_t sensorId;
	unsigned int     frameId;
	enum _CvipAckType_t ackType;
};
// @Description: This response is used for firmware to tell host that overtime
//triggered for IMC wait for CVIP ack
//++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++++++++++++++

// @RespId: RESP_ID_IMC_WAIT_CVIP_IN_IMAGE_OVERTIME
// @RespChannel: Global
// @ParameterType: Direct
// @Parameter: None
// @Description: This response is used for firmware to tell host that overtime
//triggered for IMC wait for a new input frame from CVIP
//++++++++++++++++++++++++++++++++++++++++++++++++++



//++++++++++++++++++++++++++++++++++++++++++++++++++
// @CmdId: CMD_ID_SEND_GUID
// @CmdChannel: StreamX
// @RespChannel: StreamX
// @ParameterType: Direct
// @Parameter:
struct _CmdSendGuid_t {
	struct _Guid_t secureGuid;
};
// @Description: This command
// @Type: Dynamic
// @ResponsePayload: None.
// @ResponseTime: Processed
//++++++++++++++++++++++++++++++++++++++++++++++++++


// @Parameter: struct _CmdParamPackage_t
